"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReputationClient = void 0;
const ethers_1 = require("ethers");
const constants_js_1 = require("../constants.js");
const { AddressZero } = ethers_1.constants;
class ReputationClient {
    static fetchReputation(url) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield fetch(url);
            if (response.ok) {
                return response.json();
            }
            throw new Error(`No reputation entry found for query ${url}`);
        });
    }
    constructor(network, colony, config) {
        this.colony = colony;
        this.network = network;
        const networkName = (config === null || config === void 0 ? void 0 : config.network) || constants_js_1.Network.ArbitrumOne;
        this.endpointUrl =
            (config === null || config === void 0 ? void 0 : config.customEndpointUrl) || constants_js_1.ReputationOracleEndpoint[networkName];
    }
    getRootHash(customRootHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const rootHash = customRootHash || (yield this.network.getReputationRootHash());
            if (ethers_1.BigNumber.from(rootHash).isZero()) {
                throw new Error('No reputation for given rootHash found (yet)');
            }
            return rootHash;
        });
    }
    getBaseEndpoint(customRootHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const rootHash = yield this.getRootHash(customRootHash);
            return `${this.endpointUrl}/${rootHash}/${this.colony.address}`;
        });
    }
    /**
     * Get reputation with no proofs
     *
     * Simply fetches the reputation for a user and a certain skillId.
     * Get the skillId for a domain first to check reputation in a domain.
     *
     * @example
     * ```typescript
     * const reputation = new ReputationClient(networkContract, colonyContract);
     * // Immediately executing async function
     * (async function() {
     *   // Use Id.RootDomain as domainId for Colony-wide reputation
     *   const { skillId } = await colonyContract.getDomain(domainId);
     *   const { reputationAmount } = reputation.getReputation(skillId, walletAddress);
     * })();
     * ```
     *
     * @param skillId - Skill (for corresponding domain) to check reputation in
     * @param address - User address to check reputation for
     * @param customRootHash - Optionally define a root hash in the reputation tree (historic point in time)
     *
     * @returns Reputation data
     */
    getReputation(skillId, address, customRootHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const baseEndpoint = yield this.getBaseEndpoint(customRootHash);
            const skillIdString = ethers_1.BigNumber.from(skillId || 0).toString();
            const url = `${baseEndpoint}/${skillIdString}/${address}/noProof`;
            const result = yield ReputationClient.fetchReputation(url);
            return Object.assign(Object.assign({}, result), { reputationAmount: ethers_1.BigNumber.from(result.reputationAmount || 0) });
        });
    }
    /**
     * Get reputation with proofs (e.g. to check against on-chain data)
     *
     * @param skillId - Skill (for corresponding domain) to check reputation in
     * @param address - User address to check reputation for
     * @param customRootHash - Optionally define a root hash in the reputation tree (historic point in time)
     *
     * @returns Reputation data
     */
    getReputationWithProofs(skillId, address, customRootHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const baseEndpoint = yield this.getBaseEndpoint(customRootHash);
            const skillIdString = ethers_1.BigNumber.from(skillId || 0).toString();
            const url = `${baseEndpoint}/${skillIdString}/${address}`;
            const result = yield ReputationClient.fetchReputation(url);
            return Object.assign(Object.assign({}, result), { reputationAmount: ethers_1.BigNumber.from(result.reputationAmount || 0) });
        });
    }
    /**
     * Get reputation for an address across all Colony domains
     *
     * @param address - User address to check reputation for
     * @param customRootHash - Optionally define a root hash in the reputation tree (historic point in time)
     *
     * @returns Reputation data
     */
    getReputationAcrossDomains(address, customRootHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const baseEndpoint = yield this.getBaseEndpoint(customRootHash);
            const url = `${baseEndpoint}/${address}/all`;
            const result = yield ReputationClient.fetchReputation(url);
            const domainCount = yield this.colony.getDomainCount();
            const allColonyDomains = (yield Promise.all(Array.from(new Array(domainCount.toNumber())).map((_, index) => __awaiter(this, void 0, void 0, function* () {
                const domainId = index + 1;
                const domain = yield this.colony.getDomain(domainId);
                return {
                    domainId,
                    skillId: domain.skillId.toNumber(),
                };
            })))) || [];
            return allColonyDomains.map((domain) => {
                let reputationAmount;
                const skillAssignedToDomain = ((result === null || result === void 0 ? void 0 : result.reputations) || []).find(({ skill_id: skillId }) => skillId === domain.skillId);
                if (skillAssignedToDomain) {
                    reputationAmount = skillAssignedToDomain === null || skillAssignedToDomain === void 0 ? void 0 : skillAssignedToDomain.reputationAmount;
                }
                return Object.assign(Object.assign({}, domain), { reputationAmount: reputationAmount
                        ? ethers_1.BigNumber.from(reputationAmount)
                        : undefined });
            });
        });
    }
    /**
     * Get a list of all users who have reputation in a team
     *
     * @param skillId - Skill (for corresponding domain) to check reputation in
     * @param customRootHash - Optionally define a root hash in the reputation tree (historic point in time)
     *
     * @returns Reputation data
     */
    getMembersReputation(skillId, customRootHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const baseEndpoint = yield this.getBaseEndpoint(customRootHash);
            const skillIdString = ethers_1.BigNumber.from(skillId || 0).toString();
            const url = `${baseEndpoint}/${skillIdString}`;
            return ReputationClient.fetchReputation(url);
        });
    }
    /**
     * Get the total amount of reputation points that currently are in a team
     *
     * @param skillId - Skill (for corresponding domain) to check reputation in
     * @param customRootHash - Optionally define a root hash in the reputation tree (historic point in time)
     *
     * @returns Reputation data
     */
    getTotalReputation(skillId, customRootHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const baseEndpoint = yield this.getBaseEndpoint(customRootHash);
            const skillIdString = ethers_1.BigNumber.from(skillId || 0).toString();
            const url = `${baseEndpoint}/${skillIdString}/${AddressZero}/noProof`;
            const result = yield ReputationClient.fetchReputation(url);
            return Object.assign(Object.assign({}, result), { reputationAmount: ethers_1.BigNumber.from(result.reputationAmount || 0) });
        });
    }
    /**
     * Get the reputation fraction for a user address within a team in the Colony
     *
     * 1.000 = user has 100% of the reputation
     * 0.050 = user has 5% of the reputation
     *
     * @param skillId - Skill (for corresponding domain) to check reputation in
     * @param customRootHash - Optionally define a root hash in the reputation tree (historic point in time)
     *
     * @returns Fraction of reputation a user has in a team
     */
    getReputationFraction(skillId_1, address_1, customRootHash_1) {
        return __awaiter(this, arguments, void 0, function* (skillId, address, customRootHash, decimalPoints = 3) {
            const { reputationAmount } = yield this.getReputation(skillId, address, customRootHash);
            const { reputationAmount: totalReputation } = yield this.getTotalReputation(skillId, customRootHash);
            const repAmountScaled = reputationAmount.mul(ethers_1.BigNumber.from(10).pow(decimalPoints));
            return (repAmountScaled.div(totalReputation).toNumber() / Math.pow(10, decimalPoints));
        });
    }
}
exports.ReputationClient = ReputationClient;
