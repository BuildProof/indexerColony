"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ColonyEventManager = void 0;
const ethers_1 = require("ethers");
const core_1 = require("@colony/core");
const index_js_1 = require("./ipfs/index.js");
const utils_js_1 = require("./utils.js");
/**
 * The ColonyEvents class is a wrapper around _ethers_'s event implementations to make it easier to track and fetch Colony related events.
 * It works by creating specific filters that can keep track of event sources and map filters to their respective events. This allows for
 * easy parsing of event data, without necessarily knowing the contract that emitted it.
 *
 * @remarks
 * The API is subject to change as we find more applications for this
 */
class ColonyEventManager {
    /**
     * Create a new ColonyEvents instance
     *
     * @remarks
     * As opposed to the {@link ColonyNetwork} class, this constructor _needs_ an _ethers_ JsonRpcProvider (or a subclass of it) as it's
     * the only provider that supports topic filtering by multiple addresses
     *
     * @param provider - An _ethers_ `JsonRpcProvider`
     * @param options - Optional custom {@link ColonyEventManagerOptions}
     * @returns A ColonyEvents instance
     */
    constructor(provider, options) {
        this.ipfs = new index_js_1.IpfsMetadata(options === null || options === void 0 ? void 0 : options.ipfsAdapter);
        this.provider = provider;
    }
    static extractSingleTopic(topicsContainer) {
        if (!topicsContainer || !topicsContainer.topics)
            return null;
        const topic = topicsContainer.topics;
        if (typeof topic[0] == 'string')
            return topic[0];
        if (Array.isArray(topic[0]) && typeof topic[0][0] == 'string') {
            return topic[0][0];
        }
        return null;
    }
    /**
     * Create an event source to create filters with
     *
     * This method can be used to instantiate contract event sources from virtually any
     * TypeChain ContractFactory (has to have the `.connect()` method) that can then
     * be used with the EventManager. Best to use with the contracts from `@colony/events`
     * as they all are compatible
     *
     * @example
     * Create an event source from the IColonyEventsFactory
     * ```typescript
     * import { ColonyEventManager } from '@colony/sdk';
     * import { IColonyEvents__factory as ColonyEventsFactory } from '@colony/events';
     *
     * const manager = new ColonyEventManager(provider);
     * // Event source that can be plugged into a filter creation method
     * const colonyEventSource = manager.createEventSource(ColonyEventsFactory);
     * ```
     *
     * @param contractFactory - A TypeChain compatible contract factory
     * @returns An event source contract (it's just an ethers `Contract`)
     */
    createEventSource(contractFactory) {
        return contractFactory.connect(ethers_1.constants.AddressZero, this.provider);
    }
    /**
     * Get events for a single filter
     *
     * Gets events for an individual filter and automatically parses the data if possible
     *
     * @example
     * Retrieve and parse all `DomainAdded` events for a specific {@link Colony} contract
     * ```typescript
     * const domainAdded = colonyEvents.createFilter(
     *    colonyEventSource,
     *   'DomainAdded(address,uint256)',
     *   colonyAddress,
     * );
     * // Immediately executing async function
     * (async function() {
     *   const events = await colonyEvents.getEvents(domainAdded);
     * })();
     * ```
     *
     * @param filter - A {@link ColonyFilter}, {@link ColonyMultiFilter}s will not work
     * @returns An array of {@link ColonyEvent}s
     */
    getEvents(filter) {
        return __awaiter(this, void 0, void 0, function* () {
            const logs = yield (0, utils_js_1.getLogs)(filter, this.provider);
            return logs
                .map((log) => {
                const { eventSource, eventName } = filter;
                const data = eventSource.interface.decodeEventLog(eventName, log.data, log.topics);
                if (index_js_1.IpfsMetadata.eventSupportsMetadata(eventName)) {
                    return Object.assign(Object.assign({}, filter), { data, transactionHash: log.transactionHash, getMetadata: () => __awaiter(this, void 0, void 0, function* () {
                            const result = yield this.ipfs.getMetadataForEvent(eventName, data.metadata);
                            return result;
                        }) });
                }
                return Object.assign(Object.assign({}, filter), { transactionHash: log.transactionHash, data });
            })
                .filter(core_1.nonNullable);
        });
    }
    /**
     * Get events for multiple filters across multiple addresses at once
     *
     * All the filters are connected by a logical OR, i.e. it will find ALL given events for ALL the given contract addresses
     * This is handy when you want to listen to a fixed set of events for a lot of different contracts
     *
     * @remarks
     * `fromBlock` and `toBlock` properties of the indivdual filters will be ignored
     *
     * @example
     * Retrieve and parse all `DomainAdded` and `DomainMetadata` events for a specific {@link ColonyNetwork} contract.
     * Note that we're using {@link createMultiFilter} here. The two `colonyAddress`es could also be different
     *
     * ```typescript
     * const domainAdded = colonyEvents.createMultiFilter(
     *   colonyEventSource,
     *   'DomainAdded(address,uint256)',
     *   colonyAddress,
     * );
     * const domainMetadata = colonyEvents.createMultiFilter(
     *   colonyEventSource,
     *   'DomainMetadata(address,uint256,string)',
     *   colonyAddress,
     * );
     *
     * // Immediately executing async function
     * (async function() {
     *   const events = await colonyEvents.getMultiEvents([domainAdded, domainMetadata]);
     * })();
     * ```
     *
     * @param filters - An array of {@link ColonyMultiFilter}s. Normal {@link ColonyFilter}s will not work
     * @param options - You can define `fromBlock` and `toBlock` only once for all the filters given (default for both is `latest`)
     * @returns An array of {@link ColonyEvent}s
     */
    getMultiEvents(filters_1) {
        return __awaiter(this, arguments, void 0, function* (filters, options = {}) {
            const filterArray = [].concat(filters);
            // Unique list of addresses
            const addresses = Array.from(new Set(filterArray.flatMap(({ address }) => address))).filter(core_1.nonNullable);
            // Unique list of topics
            const uniqueTopics = Array.from(new Set(filterArray.flatMap(({ colonyTopics }) => colonyTopics.map(({ topic }) => topic))));
            const logs = yield (0, utils_js_1.getLogs)({
                address: addresses.length ? addresses : undefined,
                fromBlock: options.fromBlock,
                toBlock: options.toBlock,
                topics: [uniqueTopics],
            }, this.provider);
            // TODO: I think it might be smart to just consult a database for this info
            return logs
                .map((log) => {
                const topic = ColonyEventManager.extractSingleTopic(log);
                // We are looking for a MultiFilter that defines this address but also
                // includes the topic that we're looking for so that we can decode it later
                const multiFilter = filterArray.find(({ address, colonyTopics }) => {
                    if (address && !(0, core_1.addressesAreEqual)(address, log.address)) {
                        return false;
                    }
                    return (colonyTopics.findIndex(({ topic: filterTopic }) => filterTopic === topic) > -1);
                });
                if (!multiFilter)
                    return null;
                // Now find the actual filter with the topic
                const filter = multiFilter.colonyTopics.find(({ topic: filterTopic }) => filterTopic === topic);
                if (!filter)
                    return null;
                const { eventSource, eventName } = filter;
                const data = eventSource.interface.decodeEventLog(eventName, log.data, log.topics);
                const colonyEvent = {
                    address: log.address,
                    eventSource,
                    topics: log.topics,
                    eventName,
                    data,
                    transactionHash: log.transactionHash,
                };
                if (index_js_1.IpfsMetadata.eventSupportsMetadata(eventName)) {
                    return Object.assign(Object.assign({}, colonyEvent), { getMetadata: () => __awaiter(this, void 0, void 0, function* () {
                            const result = yield this.ipfs.getMetadataForEvent(eventName, data.metadata);
                            return result;
                        }) });
                }
                return colonyEvent;
            })
                .filter(core_1.nonNullable);
        });
    }
    // We split up the type definition and the actual implementation to relax the TypeScript strictness a little bit for the implementation so it won't go crazy.
    // eslint-disable-next-line class-methods-use-this
    createFilter(eventSource, eventName, address, params, options = {}) {
        // Create standard filter
        const filter = params
            ? eventSource.filters[eventName].apply([
                eventSource.filters[eventName],
                ...params,
            ])
            : eventSource.filters[eventName]();
        return {
            eventSource,
            eventName: eventName,
            topics: filter.topics,
            address,
            fromBlock: options.fromBlock,
            toBlock: options.toBlock,
        };
    }
    /**
     * Create a {@link ColonyMultiFilter} that keeps track of its event source and can work alongside other filters in {@link getMultiEvents}
     *
     * The {@link ColonyMultiFilter} works much like the {@link ColonyFilter}, just that we _have_ to specify an address of the contract which emits this event.
     * Furthermore, no `fromBlock` or `toBlock` requirements can be given (that is done on a global level in {@link getMultiEvents})
     *
     * @remarks
     * We can do that as we do not have ambiguous events across our contracts, so we will always be able to find the right contract to parse the event data later on. Note that `ColonyMultiFilter` does not allow for params to be passed in.
     *
     * @example
     * Filter for all `DomainAdded` events for a specific {@link Colony} contract
     * ```typescript
     * const domainAdded = colonyEvents.createFilter(
     *   colonyEventSource,
     *   'DomainAdded(address,uint256)',
     *   colonyAddress,
     * );
     * ```
     *
     * @typeParam T - Needs to be a valid {@link EventSource} (i.e. from `colonyEvents.eventSources`)
     * @typeParam N - An event signature as defined in the _ethers_ contract's [`filters`](https://docs.ethers.io/v5/api/contract/contract/#Contract--filters) object.
     * See the [ColonyJS documentation](https://colony.gitbook.io/colony/colonyjs) for a list of all available contracts and events
     *
     * @param contract - A valid {@link EventSource}
     * @param eventNames - A list of valid event signatures from the contract's `filters` object
     * @param address - Address of the contract that can emit this event. Will listen to any contract if not provided
     * @returns A {@link ColonyMultiFilter}
     */
    createMultiFilter(contract, eventNames, address) {
        const colonyTopics = eventNames
            .map((eventName) => {
            const filter = this.createFilter(contract, eventName, address);
            // As we don't allow parameters, filter.topics should always be a single topic
            const topic = ColonyEventManager.extractSingleTopic(filter);
            if (!topic)
                return null;
            return {
                topic,
                eventName: eventName,
                eventSource: filter.eventSource,
            };
        })
            .filter(core_1.nonNullable);
        return {
            address,
            colonyTopics,
        };
    }
}
exports.ColonyEventManager = ColonyEventManager;
