import ts from "typescript";
import { MetadataCollection } from "../factories/MetadataCollection";
import { IMetadataTag } from "../metadata/IMetadataTag";
import { Metadata } from "../metadata/Metadata";
import { MetadataObject } from "../metadata/MetadataObject";
import { IProject } from "../transformers/IProject";
import { FeatureProgrammer } from "./FeatureProgrammer";
import { FunctionImporter } from "./helpers/FunctionImporeter";
import { ICheckEntry } from "./helpers/ICheckEntry";
import { IExpressionEntry } from "./helpers/IExpressionEntry";
export declare namespace CheckerProgrammer {
    interface IConfig {
        functors: string;
        unioners: string;
        path: boolean;
        trace: boolean;
        equals: boolean;
        numeric: boolean;
        addition?: () => ts.Statement[];
        decoder?: FeatureProgrammer.Decoder<Metadata, ts.Expression>;
        combiner: IConfig.Combiner;
        atomist: (explore: IExplore) => (check: ICheckEntry) => (input: ts.Expression) => ts.Expression;
        joiner: IConfig.IJoiner;
        success: ts.Expression;
    }
    namespace IConfig {
        interface Combiner {
            (explorer: IExplore): {
                (logic: "and" | "or"): {
                    (input: ts.Expression, binaries: IBinary[], expected: string): ts.Expression;
                };
            };
        }
        interface IJoiner {
            object(input: ts.Expression, entries: IExpressionEntry[]): ts.Expression;
            array(input: ts.Expression, arrow: ts.ArrowFunction): ts.Expression;
            tuple?(exprs: ts.Expression[]): ts.Expression;
            failure(value: ts.Expression, expected: string, explore?: FeatureProgrammer.IExplore): ts.Expression;
            is?(expression: ts.Expression): ts.Expression;
            required?(exp: ts.Expression): ts.Expression;
            full?: (condition: ts.Expression) => (input: ts.Expression, expected: string, explore: IExplore) => ts.Expression;
        }
    }
    type IExplore = FeatureProgrammer.IExplore;
    interface IBinary {
        expression: ts.Expression;
        combined: boolean;
    }
    const write: (project: IProject) => (config: IConfig) => (importer: FunctionImporter) => (type: ts.Type, name?: string | undefined) => ts.ArrowFunction;
    const write_functors: (project: IProject) => (config: IConfig) => (importer: FunctionImporter) => (collection: MetadataCollection) => ts.VariableStatement[];
    const write_unioners: (project: IProject, config: IConfig, importer: FunctionImporter) => (collection: MetadataCollection) => ts.VariableStatement[];
    const decode_tuple: (project: IProject) => (config: IConfig) => (importer: FunctionImporter) => (checkLength: boolean) => (input: ts.Expression, tuple: Array<Metadata>, explore: IExplore, tagList: IMetadataTag[], jsDocTags: ts.JSDocTagInfo[]) => ts.Expression;
    const decode_object: (config: IConfig) => (importer: FunctionImporter) => (input: ts.Expression, obj: MetadataObject, explore: IExplore) => ts.CallExpression;
}
