import { type BigNumberish, type ContractReceipt } from 'ethers';
import { type SignerOrProvider } from '@colony/core';
import { type ERC2612Token as ERC2612TokenType } from '@colony/tokens';
import { type ColonyData, type ColonyEvents, type ColonyNetworkEvents, MetadataType } from '@colony/events';
import { type IColonyNetwork, type IBasicMetaTransaction } from '../contracts/index.js';
import { type BaseContract, type TxConfig, TxCreator, MetaTxCreator } from '../TxCreator/index.js';
import { Colony } from './Colony.js';
import { type Expand, type Parameters } from '../types.js';
import { EIP2612TxCreator } from '../TxCreator/EIP2612TxCreator.js';
import { TokenLocking } from './TokenLocking.js';
import { ContractConfig, type ContractOptions } from '../ContractConfig.js';
/** ERC20 Token information */
export interface TokenData {
    /** The token's name (e.g. Colony Network Token) */
    name: string;
    /** The token's symbol (e.g. CLNY) */
    symbol: string;
    /** The token's decimals (defaults to 18) */
    decimals?: number;
}
export declare class ColonyNetwork {
    private contract;
    private locking?;
    /** Configuration of the ColonyNetwork for later use */
    /** @internal */
    config: ContractConfig;
    /**
     * Creates a new instance of the ColonyNetwork
     *
     * This is your main entry point to talk to the Colony Network Smart Contracts.
     * From here you should be able to instantiate all the required instances for Colonies and their extensions.
     *
     * @example
     *
     * ```typescript
     * import { providers } from 'ethers';
     * import { ColonyNetwork, ColonyRpcEndpoint, Tokens } from '@colony/sdk';
     *
     * // Connect directly to the deployed Colony Network on Arbitrum One
     * const provider = new providers.JsonRpcProvider(ColonyRpcEndpoint.ArbitrumOne);
     * const colonyNetwork = new ColonyNetwork(provider);
     * // Now you could call functions on the colonyNetwork, like `colonyNetwork.getMetaColony()`
     * ```
     *
     * @param signerOrProvider - An _ethers_ compatible Signer or Provider instance
     * @param options - Optional custom {@link ColonyNetworkOptions}
     * @returns A ColonyNetwork abstraction instance
     */
    constructor(signerOrProvider: SignerOrProvider, options?: ContractOptions);
    /**
     * Fetches the TokenLocking client abstraction
     *
     * @returns A {@link TokenLocking} contract client
     */
    getTokenLocking(): Promise<TokenLocking>;
    /**
     * Provide direct access to the internally used ethers Contract. Only use when you know what you're doing
     *
     * @internal
     * @returns The internally used ethers Contract
     */
    getInternalNetworkContract(): IColonyNetwork;
    /**
     * Creates a new {@link TxCreator} for non-meta, non-motion transactions
     * @internal
     *
     * @remarks
     * Do not use this method directly but rather the class methods in the Colony or extensions
     *
     * @param contract - A ColonyJS contract
     * @param method - The transaction method to execute on the contract
     * @param args - The arguments for the method
     * @param eventData - A function that extracts the relevant event data from the {@link ContractReceipt}
     * @param txConfig - More configuration options, like {@link MetadataType} if the event contains metadata or if methods are unsupported
     * @returns A {@link TxCreator}
     */
    createTxCreator<C extends BaseContract, F extends keyof C['functions'], D extends Record<string, unknown>, M extends MetadataType>(contract: C, method: F, args: Parameters<C['functions'][F]> | (() => Promise<Parameters<C['functions'][F]>>), eventData?: (receipt: ContractReceipt) => Promise<D>, txConfig?: TxConfig<M>): TxCreator<C, F, D, M>;
    /**
     * Creates a new {@link MetaTxCreator} for possibly meta, non-motion transactions
     * @internal
     *
     * @remarks
     * Do not use this method directly but rather the class methods in the Colony or extensions
     *
     * @param contract - A ColonyJS contract
     * @param method - The transaction method to execute on the contract
     * @param args - The arguments for the method
     * @param eventData - A function that extracts the relevant event data from the {@link ContractReceipt}
     * @param txConfig - More configuration options, like {@link MetadataType} if the event contains metadata or if methods are unsupported
     * @returns A {@link MetaTxCreator}
     */
    createMetaTxCreator<C extends IBasicMetaTransaction, F extends keyof C['functions'], D extends Record<string, unknown>, M extends MetadataType>(contract: C, method: F, args: Parameters<C['functions'][F]> | (() => Promise<Parameters<C['functions'][F]>>), eventData?: (receipt: ContractReceipt) => Promise<D>, txConfig?: TxConfig<M>): MetaTxCreator<C, F, D, M>;
    /**
     * Creates a new {@link EIP2612TxCreator} for EIP-2612 transactions (permit)
     * @internal
     *
     * @remarks
     * Do not use this method directly but rather the class methods in the Colony or extensions
     *
     * @param contract - Only a EIP-2612 compatible token contract
     * @param method - Can only do 'permit'
     * @param args - The arguments for the 'permit' method
     * @param eventData - A function that extracts the relevant event data from the {@link ContractReceipt}
     * @param txConfig - More configuration options, like {@link MetadataType} if the event contains metadata or if methods are unsupported
     * @returns A {@link EIP2612TxCreator}
     */
    createEip2612TxCreator<D extends Record<string, unknown>, M extends MetadataType>(contract: ERC2612TokenType, method: 'permit', args: [string, BigNumberish] | (() => Promise<[string, BigNumberish]>), eventData?: (receipt: ContractReceipt) => Promise<D>, txConfig?: TxConfig<M>): EIP2612TxCreator<D, M>;
    /**
     * Create a new colony with metadata
     *
     * Creates a new colony with IPFS metadata. To edit metadata at a later point you can call the {@link Colony.edit} method.
     *
     * @remarks
     * There is more to creating a fully functional colony that can be used within the dapp than just calling this function.
     * See the [Colony Creation Guide](../../guides/colony-creation.md).
     *
     * @example
     * ```typescript
     * import { Tokens } from '@colony/sdk';
     *
     * // Immediately executing async function
     * (async function() {
     *   // Create a colony with some metadata details attached
     *   // (forced transaction example)
     *   // (also notice that this requires an upload-capable IPFS adapter)
     *   await colonyNetwork.createColony(
     *     // Create a new token ('COOL') for this Colony
     *     { name: 'Cool token', symbol: 'COOL' },
     *     'coolony',
     *     {
     *       colonyDisplayName: 'Cool Colony',
     *       // IPFS hash to an image file
     *       colonyAvatarHash: 'QmS26o1Cmsrx7iw1SSFGEcy22TVDq6VmEZ4XNjpWFyaKUe',
     *       // List of token addresses that the Colony should be initialized with (can be changed later) - excluding ETH and the native token from above
     *       colonyTokens: [Tokens.ArbitrumOne.CLNY],
     *     }).tx().mined();
     * })();
     * ```
     *
     * @param token - Create a new ERC20-compatible token by passing in its name and symbol or use an existing token by passing in its contract address
     * @param label - The Colony's label. This is going to be part of the URL to look up the Colony within the dApp
     * @param metadata - The team metadata you would like to add (or an IPFS CID pointing to valid metadata). If {@link ColonyData} is provided directly (as opposed to a [CID](https://docs.ipfs.io/concepts/content-addressing/#identifier-formats) for a JSON file) this requires an {@link IpfsAdapter} that can upload and pin to IPFS (like the {@link PinataAdapter}). See its documentation for more information.
     *
     * @returns A transaction creator
     *
     * #### Event data
     *
     * | Property | Type | Description |
     * | :------ | :------ | :------ |
     * | `colonyId` | BigNumber | Auto-incremented integer id of the colony |
     * | `colonyAddress` | string | Address of the newly deployed colony contract |
     * | `tokenAddress` | string | Address of the token that is used as the colony's native token |
     * | `tokenAuthorityAddress` | string | Address of the token authority (the token's permission manager) contract |
     * | `token` | string | Alias of `token`
     * | `metadata` | string | IPFS CID of metadata attached to this transaction |
     *
     * #### Metadata
     *
     * (can be obtained by calling and awaiting the `getMetadata` function)
     *
     * | Property | Type | Description |
     * | :------ | :------ | :------ |
     * | `colonyDisplayName` | string | The name that should be displayed for the colony |
     * | `colonyAvatarHash` | string | An IPFS hash for a Colony logo (make it 200x200px) |
     * | `colonyTokens` | string[] | A list of additional tokens that should be in the colony's "address book" |
     */
    createColony(token: string | TokenData, label: string, metadata: ColonyData | string): MetaTxCreator<IColonyNetwork, 'createColonyForFrontend', Expand<ColonyNetworkEvents.TokenDeployedEventObject & ColonyNetworkEvents.ColonyAddedEventObject & ColonyNetworkEvents.TokenAuthorityDeployedEventObject & ColonyEvents.ColonyMetadataEventObject>, MetadataType.Colony>;
    /**
     * Create a new Colony without metadata
     *
     * Creates a new Colony without IPFS metadata. To add metadata at a later point you can call the {@link Colony.edit} method.
     *
     * @remarks
     * There is more to creating a fully functional colony that can be used within the dapp than just calling this function.
     * See the [Colony Creation Guide](../../guides/colony-creation.md).
     *
     * @example
     * ```typescript
     * // Immediately executing async function
     * (async function() {
     *   // Create a colony
     *   // (forced transaction example)
     *   await colonyNetwork
     *     // Use USDC on Arbitrum One as the native token
     *     .createColony('0xDDAfbb505ad214D7b80b1f830fcCc89B60fb7A83', 'coolony')
     *     .tx().mined();
     * })();
     * ```
     *
     * @param token - Create a new ERC20-compatible token by passing in its name and symbol or use an existing token by passing in its contract address
     * @param label - The Colony's label. This is going to be part of the URL to look up the Colony within the dApp
     *
     * @returns A transaction creator
     *
     * #### Event data
     *
     * | Property | Type | Description |
     * | :------ | :------ | :------ |
     * | `colonyId` | BigNumber | Auto-incremented integer id of the colony |
     * | `colonyAddress` | string | Address of the newly deployed colony contract |
     * | `tokenAddress` | string | Address of the token that is used as the colony's native token |
     * | `tokenAuthorityAddress` | string | Address of the token authority (the token's permission manager) contract |
     * | `token` | string | Alias of `token`
     */
    createColony(token: string | TokenData, label: string): MetaTxCreator<IColonyNetwork, 'createColonyForFrontend', Expand<ColonyNetworkEvents.TokenDeployedEventObject & ColonyNetworkEvents.ColonyAddedEventObject & ColonyNetworkEvents.TokenAuthorityDeployedEventObject & {
        metadata?: undefined;
    }>, MetadataType>;
    /**
     * Get a new instance of a Colony
     *
     * Use this function to instantiate a new `Colony` by providing the Colony's address
     *
     * @remarks
     * Colony contracts are versioned. If the deployed Colony version does not match the supported version an error will be thrown
     *
     * @param address - The Colony's address
     * @returns A Colony abstaction instance
     */
    getColony(address: string): Promise<Colony>;
    /**
     * Get a new instance of the MetaColony
     *
     * Use this function to instantiate a new `Colony` for the deployed MetaColony
     *
     * @returns A Colony abstaction instance of the MetaColony
     */
    getMetaColony(): Promise<Colony>;
    /**
     * Get the colony's ENS label
     *
     * Returns the colony's ENS label, just like it's shown in the browsers address bar after `/colony/`, when using the dApp.
     * Will return `null` if the colony does not exist or if no label was assigned yet
     *
     * @returns The colony's ENS label
     */
    getColonyLabel(address: string): Promise<string | null>;
    /**
     * Get the colony's addess by the ENS label
     *
     * Returns the colony's address that belongs to the given ENS label
     * Will return `null` if the given label was not assigned to a colony.
     *
     * @returns The colony's address
     */
    getColonyAddress(label: string): Promise<string | null>;
    /**
     * Get a user's username
     *
     * Returns the user's username (the ENS label, just like it's shown in the dapp, without any suffixes)
     * Will return `null` if the user does not exist or if no label was assigned yet
     *
     * @returns The user's username
     */
    getUsername(address: string): Promise<string | null>;
    /**
     * Get the user's addess by the username
     *
     * Returns the user's address that belongs to the given username. Username has to be provided without any suffix, just like it's shown in the dapp.
     * Will return `null` if the given username was not registered.
     *
     * @returns The user's address
     */
    getUserAddress(username: string): Promise<string | null>;
    /**
     * Register a Colony-internal ENS username
     *
     * Registers a username for the signing address. An address can only register one username. Usernames are globally unique. This method will check whether the username was registered before.
     *
     * @returns A transaction creator
     */
    registerUsername(username: string): MetaTxCreator<IColonyNetwork, "registerUserLabel", {
        user?: string | undefined;
        label?: string | undefined;
    }, MetadataType>;
    /**
     * Deploy a "special" Colony ERC20 token
     *
     * If there is not token yet that should be used with the Colony, this is the canonical way to create one.
     *
     * This is a supercharged ERC20 token contract, that not only has a permissioned `mint` function (that can be used from the colony) but also supports Metatransactions. In order to fully use its permissioned system with a Colony, some extra steps have to be taken. See the [Colony Creation Guide](../../guides/colony-creation.md).
     *
     * @remarks
     * The token deployed with this function is locked by default. Call `unlockToken()` on the Colony at a later point to unlock it.
     *
     * @returns A transaction creator
     */
    deployToken(name: string, symbol: string, decimals?: number): MetaTxCreator<IColonyNetwork, "deployTokenViaNetwork", {
        tokenAddress?: string | undefined;
    }, MetadataType>;
}
