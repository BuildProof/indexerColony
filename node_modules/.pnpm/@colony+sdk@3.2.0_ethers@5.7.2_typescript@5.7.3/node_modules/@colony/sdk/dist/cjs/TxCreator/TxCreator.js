"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxCreator = void 0;
const core_1 = require("@colony/core");
const events_1 = require("@colony/events");
/**
 * An umbrella API for all kinds of transactions
 *
 * The `TxCreator` allows for a simple API to cover all the different cases of transactions within the Colony Network. This is the base class of the TxCreator that only supports the `tx()` action and no metatransactions.
 *
 * ## Create a standard transaction ("force" in dApp)
 *
 * - {@link TxCreator.tx}: force a Colony transaction, knowing you have the permissions to do so
 *
 * Learn more about these functions in their individual documentation
 */
class TxCreator {
    constructor({ contract, config, method, args, eventData, txConfig, }) {
        this.config = config;
        this.contract = contract;
        this.method = method;
        this.args = args;
        this.eventData = eventData;
        this.txConfig = txConfig;
    }
    getArgs(overrides) {
        return __awaiter(this, void 0, void 0, function* () {
            let args = [];
            if (typeof this.args == 'function') {
                args = yield this.args();
            }
            else {
                args = this.args;
            }
            if (overrides) {
                args.push(overrides);
            }
            return args;
        });
    }
    getTx(overrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = yield this.getArgs(overrides);
            const tx = (yield this.contract.functions[this.method].apply(this.contract, args));
            return tx;
        });
    }
    getMined(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            const receipt = yield tx.wait();
            return this.getEventData(receipt);
        });
    }
    getEventData(receipt) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (this.eventData) {
                const data = yield this.eventData(receipt);
                if (((_a = this.txConfig) === null || _a === void 0 ? void 0 : _a.metadataType) && data.metadata) {
                    const getMetadata = this.config.ipfs.getMetadataForEvent.bind(this.config.ipfs, events_1.IpfsMetadataEvents[this.txConfig.metadataType], data.metadata);
                    return [data, receipt, getMetadata];
                }
                return [data, receipt];
            }
            return [{}, receipt];
        });
    }
    broadcastMetaTx(broadcastData) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const { provider } = this.config.getSigner();
            if (!provider) {
                throw new Error('No provider found');
            }
            const res = yield fetch(`${this.config.metaTxBroadcasterEndpoint}/broadcast`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(broadcastData),
            });
            const parsed = yield res.json();
            if (parsed.status !== 'success') {
                throw new Error(`Could not send Metatransaction. Reason given: ${parsed.data.reason}`);
            }
            if (!((_a = parsed.data) === null || _a === void 0 ? void 0 : _a.txHash)) {
                throw new Error('Could not get transaction hash from broadcaster response');
            }
            yield provider.waitForTransaction(parsed.data.txHash);
            return provider.getTransaction(parsed.data.txHash);
        });
    }
    waitForMetaTx(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            const receipt = (yield tx.wait());
            receipt.parsedLogs = (0, core_1.parseLogs)(receipt.logs, this.contract.interface);
            return receipt;
        });
    }
    /**
     * Create a standard transaction ("force" in dApp)
     *
     * See also {@link ColonyTransaction} or https://docs.colony.io/colonysdk/guides/transactions for more information
     *
     * @remarks The user sending this transaction has to have the appropriate permissions to do so. Learn more about permissions in Colony [here](/develop/dev-learning/permissions).
     *
     * @returns A transaction that can be `send`, `mined` or `encode`d.
     */
    tx() {
        return {
            send: (overrides) => __awaiter(this, void 0, void 0, function* () {
                const tx = yield this.getTx(overrides);
                return [tx, this.getMined.bind(this, tx)];
            }),
            mined: (overrides) => __awaiter(this, void 0, void 0, function* () {
                const tx = yield this.getTx(overrides);
                return this.getMined(tx);
            }),
            encode: () => __awaiter(this, void 0, void 0, function* () {
                const args = yield this.getArgs();
                return this.contract.interface.encodeFunctionData(this.method, args);
            }),
        };
    }
}
exports.TxCreator = TxCreator;
