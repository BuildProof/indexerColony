"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractConfig = void 0;
const core_1 = require("@colony/core");
const events_1 = require("@colony/events");
const ethers_1 = require("ethers");
/**
 * @internal
 * Used to store auxiliare contract information and helpers
 */
class ContractConfig {
    constructor(signerOrProvider, options) {
        const network = (options === null || options === void 0 ? void 0 : options.network) || core_1.Network.ArbitrumOne;
        // TODO: for validation: if network is Custom, metaTxBroadcaster and reputationOracleEndpoint have to be set
        this.metaTxBroadcasterEndpoint =
            (options === null || options === void 0 ? void 0 : options.metaTxBroadcasterEndpoint) || core_1.MetaTxBroadCasterEndpoint[network];
        this.ipfs = new events_1.IpfsMetadata(options === null || options === void 0 ? void 0 : options.ipfsAdapter);
        this.network = network;
        this.reputationOracleEndpoint =
            (options === null || options === void 0 ? void 0 : options.reputationOracleEndpoint) || core_1.ReputationOracleEndpoint[network];
        this.signerOrProvider = signerOrProvider;
    }
    /**
     * Get the signer that was provided when the ColonyNetwork was instantiated.
     * Throws if the Signer is only a (read-only) Provider
     *
     * @returns An Ethers.js compatible Signer instance
     */
    getSigner() {
        if (!(this.signerOrProvider instanceof ethers_1.Signer)) {
            throw new Error('Need a signer to create a transaction');
        }
        return this.signerOrProvider;
    }
}
exports.ContractConfig = ContractConfig;
