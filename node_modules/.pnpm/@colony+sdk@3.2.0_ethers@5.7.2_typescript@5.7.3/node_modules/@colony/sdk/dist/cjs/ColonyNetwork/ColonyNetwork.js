"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ColonyNetwork = void 0;
const ethers_1 = require("ethers");
const core_1 = require("@colony/core");
const events_1 = require("@colony/events");
const index_js_1 = require("../contracts/index.js");
const index_js_2 = require("../TxCreator/index.js");
const Colony_js_1 = require("./Colony.js");
const utils_js_1 = require("../utils.js");
const EIP2612TxCreator_js_1 = require("../TxCreator/EIP2612TxCreator.js");
const TokenLocking_js_1 = require("./TokenLocking.js");
const ContractConfig_js_1 = require("../ContractConfig.js");
const { namehash } = ethers_1.utils;
const { AddressZero } = ethers_1.constants;
class ColonyNetwork {
    /**
     * Creates a new instance of the ColonyNetwork
     *
     * This is your main entry point to talk to the Colony Network Smart Contracts.
     * From here you should be able to instantiate all the required instances for Colonies and their extensions.
     *
     * @example
     *
     * ```typescript
     * import { providers } from 'ethers';
     * import { ColonyNetwork, ColonyRpcEndpoint, Tokens } from '@colony/sdk';
     *
     * // Connect directly to the deployed Colony Network on Arbitrum One
     * const provider = new providers.JsonRpcProvider(ColonyRpcEndpoint.ArbitrumOne);
     * const colonyNetwork = new ColonyNetwork(provider);
     * // Now you could call functions on the colonyNetwork, like `colonyNetwork.getMetaColony()`
     * ```
     *
     * @param signerOrProvider - An _ethers_ compatible Signer or Provider instance
     * @param options - Optional custom {@link ColonyNetworkOptions}
     * @returns A ColonyNetwork abstraction instance
     */
    constructor(signerOrProvider, options) {
        this.config = new ContractConfig_js_1.ContractConfig(signerOrProvider, options);
        this.contract = index_js_1.IColonyNetwork__factory.connect((options === null || options === void 0 ? void 0 : options.customNetworkAddress) ||
            core_1.ColonyNetworkAddress[this.config.network], signerOrProvider);
    }
    /**
     * Fetches the TokenLocking client abstraction
     *
     * @returns A {@link TokenLocking} contract client
     */
    getTokenLocking() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.locking) {
                const address = yield this.contract.getTokenLocking();
                this.locking = new TokenLocking_js_1.TokenLocking(this, address);
            }
            return this.locking;
        });
    }
    /**
     * Provide direct access to the internally used ethers Contract. Only use when you know what you're doing
     *
     * @internal
     * @returns The internally used ethers Contract
     */
    getInternalNetworkContract() {
        return this.contract;
    }
    /**
     * Creates a new {@link TxCreator} for non-meta, non-motion transactions
     * @internal
     *
     * @remarks
     * Do not use this method directly but rather the class methods in the Colony or extensions
     *
     * @param contract - A ColonyJS contract
     * @param method - The transaction method to execute on the contract
     * @param args - The arguments for the method
     * @param eventData - A function that extracts the relevant event data from the {@link ContractReceipt}
     * @param txConfig - More configuration options, like {@link MetadataType} if the event contains metadata or if methods are unsupported
     * @returns A {@link TxCreator}
     */
    createTxCreator(contract, method, args, eventData, txConfig) {
        return new index_js_2.TxCreator({
            config: this.config,
            contract,
            method,
            args,
            eventData,
            txConfig,
        });
    }
    /**
     * Creates a new {@link MetaTxCreator} for possibly meta, non-motion transactions
     * @internal
     *
     * @remarks
     * Do not use this method directly but rather the class methods in the Colony or extensions
     *
     * @param contract - A ColonyJS contract
     * @param method - The transaction method to execute on the contract
     * @param args - The arguments for the method
     * @param eventData - A function that extracts the relevant event data from the {@link ContractReceipt}
     * @param txConfig - More configuration options, like {@link MetadataType} if the event contains metadata or if methods are unsupported
     * @returns A {@link MetaTxCreator}
     */
    createMetaTxCreator(contract, method, args, eventData, txConfig) {
        return new index_js_2.MetaTxCreator({
            config: this.config,
            contract,
            method,
            args,
            eventData,
            txConfig,
        });
    }
    /**
     * Creates a new {@link EIP2612TxCreator} for EIP-2612 transactions (permit)
     * @internal
     *
     * @remarks
     * Do not use this method directly but rather the class methods in the Colony or extensions
     *
     * @param contract - Only a EIP-2612 compatible token contract
     * @param method - Can only do 'permit'
     * @param args - The arguments for the 'permit' method
     * @param eventData - A function that extracts the relevant event data from the {@link ContractReceipt}
     * @param txConfig - More configuration options, like {@link MetadataType} if the event contains metadata or if methods are unsupported
     * @returns A {@link EIP2612TxCreator}
     */
    createEip2612TxCreator(contract, method, args, eventData, txConfig) {
        return new EIP2612TxCreator_js_1.EIP2612TxCreator({
            config: this.config,
            contract,
            method,
            args,
            eventData,
            txConfig,
        });
    }
    createColony(token, label, metadata) {
        const prepareArgs = () => __awaiter(this, void 0, void 0, function* () {
            const existingAddress = yield this.getColonyAddress(label);
            if (existingAddress) {
                throw new Error(`Colony with label ${label} already exists`);
            }
            // TODO: check all arguments for existance
            if (typeof token != 'string') {
                if (!token.name) {
                    throw new Error('Token name is required');
                }
                if (!token.symbol) {
                    throw new Error('Token symbol is required');
                }
                // TODO: check decimals type
                return [
                    AddressZero,
                    token.name,
                    token.symbol,
                    token.decimals || 18,
                    0,
                    label,
                    '',
                ];
            }
            return [token, '', '', 0, 0, label, ''];
        });
        if (!metadata) {
            return this.createMetaTxCreator(this.contract, 'createColonyForFrontend', prepareArgs, (receipt) => __awaiter(this, void 0, void 0, function* () {
                return (Object.assign(Object.assign(Object.assign({}, (0, utils_js_1.extractEvent)('TokenDeployed', receipt)), (0, utils_js_1.extractEvent)('ColonyAdded', receipt)), (0, utils_js_1.extractEvent)('TokenAuthorityDeployed', receipt)));
            }));
        }
        return this.createMetaTxCreator(this.contract, 'createColonyForFrontend', () => __awaiter(this, void 0, void 0, function* () {
            const args = yield prepareArgs();
            if (typeof metadata == 'string') {
                args[6] = metadata;
            }
            else {
                args[6] = yield this.config.ipfs.uploadMetadata(events_1.MetadataType.Colony, metadata);
            }
            return args;
        }), (receipt) => __awaiter(this, void 0, void 0, function* () {
            return (Object.assign(Object.assign(Object.assign({}, (0, utils_js_1.extractEvent)('TokenDeployed', receipt)), (0, utils_js_1.extractEvent)('ColonyAdded', receipt)), (0, utils_js_1.extractEvent)('TokenAuthorityDeployed', receipt)));
        }), {
            metadataType: events_1.MetadataType.Colony,
        });
    }
    /**
     * Get a new instance of a Colony
     *
     * Use this function to instantiate a new `Colony` by providing the Colony's address
     *
     * @remarks
     * Colony contracts are versioned. If the deployed Colony version does not match the supported version an error will be thrown
     *
     * @param address - The Colony's address
     * @returns A Colony abstaction instance
     */
    getColony(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return Colony_js_1.Colony.connect(this, address);
        });
    }
    /**
     * Get a new instance of the MetaColony
     *
     * Use this function to instantiate a new `Colony` for the deployed MetaColony
     *
     * @returns A Colony abstaction instance of the MetaColony
     */
    getMetaColony() {
        return __awaiter(this, void 0, void 0, function* () {
            const colonyAddress = yield this.contract.getMetaColony();
            return this.getColony(colonyAddress);
        });
    }
    /**
     * Get the colony's ENS label
     *
     * Returns the colony's ENS label, just like it's shown in the browsers address bar after `/colony/`, when using the dApp.
     * Will return `null` if the colony does not exist or if no label was assigned yet
     *
     * @returns The colony's ENS label
     */
    getColonyLabel(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const ensName = yield this.contract.lookupRegisteredENSDomain(address);
            if (ensName) {
                return ensName.replace(core_1.ColonyLabelSuffix[this.config.network], '');
            }
            return null;
        });
    }
    /**
     * Get the colony's addess by the ENS label
     *
     * Returns the colony's address that belongs to the given ENS label
     * Will return `null` if the given label was not assigned to a colony.
     *
     * @returns The colony's address
     */
    getColonyAddress(label) {
        return __awaiter(this, void 0, void 0, function* () {
            const hash = namehash(`${label}${core_1.ColonyLabelSuffix[this.config.network]}`);
            const address = yield this.contract.addr(hash);
            if (address !== AddressZero) {
                return address;
            }
            return null;
        });
    }
    /**
     * Get a user's username
     *
     * Returns the user's username (the ENS label, just like it's shown in the dapp, without any suffixes)
     * Will return `null` if the user does not exist or if no label was assigned yet
     *
     * @returns The user's username
     */
    getUsername(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const ensName = yield this.contract.lookupRegisteredENSDomain(address);
            if (ensName) {
                return ensName.replace(core_1.UserLabelSuffix[this.config.network], '');
            }
            return null;
        });
    }
    /**
     * Get the user's addess by the username
     *
     * Returns the user's address that belongs to the given username. Username has to be provided without any suffix, just like it's shown in the dapp.
     * Will return `null` if the given username was not registered.
     *
     * @returns The user's address
     */
    getUserAddress(username) {
        return __awaiter(this, void 0, void 0, function* () {
            const hash = namehash(`${username}${core_1.UserLabelSuffix[this.config.network]}`);
            const address = yield this.contract.addr(hash);
            if (address !== AddressZero) {
                return address;
            }
            return null;
        });
    }
    /**
     * Register a Colony-internal ENS username
     *
     * Registers a username for the signing address. An address can only register one username. Usernames are globally unique. This method will check whether the username was registered before.
     *
     * @returns A transaction creator
     */
    registerUsername(username) {
        const checkUsername = () => __awaiter(this, void 0, void 0, function* () {
            const existingAddress = yield this.getColonyAddress(username);
            if (existingAddress) {
                throw new Error(`Username ${username} is already taken`);
            }
            return [username, ''];
        });
        return this.createMetaTxCreator(this.contract, 'registerUserLabel', checkUsername, (receipt) => __awaiter(this, void 0, void 0, function* () {
            return (Object.assign({}, (0, utils_js_1.extractEvent)('UserLabelRegistered', receipt)));
        }));
    }
    /**
     * Deploy a "special" Colony ERC20 token
     *
     * If there is not token yet that should be used with the Colony, this is the canonical way to create one.
     *
     * This is a supercharged ERC20 token contract, that not only has a permissioned `mint` function (that can be used from the colony) but also supports Metatransactions. In order to fully use its permissioned system with a Colony, some extra steps have to be taken. See the [Colony Creation Guide](../../guides/colony-creation.md).
     *
     * @remarks
     * The token deployed with this function is locked by default. Call `unlockToken()` on the Colony at a later point to unlock it.
     *
     * @returns A transaction creator
     */
    deployToken(name, symbol, decimals = 18) {
        return this.createMetaTxCreator(this.contract, 'deployTokenViaNetwork', [name, symbol, decimals], (receipt) => __awaiter(this, void 0, void 0, function* () {
            return (Object.assign({}, (0, utils_js_1.extractEvent)('TokenDeployed', receipt)));
        }));
    }
}
exports.ColonyNetwork = ColonyNetwork;
