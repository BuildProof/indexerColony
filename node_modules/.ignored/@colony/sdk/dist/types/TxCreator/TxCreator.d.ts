import type { TransactionResponse } from '@ethersproject/abstract-provider';
import { type Contract, type ContractReceipt, type ContractTransaction } from 'ethers';
import { type TxOverrides } from '@colony/core';
import { type MetadataTypeMap, type VotingReputationEvents, type MetadataType } from '@colony/events';
import { type ParsedLogTransactionReceipt } from '../types.js';
import { type ContractConfig } from '../ContractConfig.js';
export interface TxConfig<M = MetadataType.DEFAULT> {
    metadataType?: M;
}
export interface EventData {
    metadata?: string;
}
export interface TxCreatorConfig<C, M, E, MD> {
    contract: C;
    config: ContractConfig;
    method: M;
    args: unknown[] | (() => Promise<unknown[]>);
    eventData?: (receipt: ContractReceipt) => Promise<E>;
    metadataType?: MD;
    txConfig?: TxConfig<MD>;
}
export interface BaseContract {
    address: string;
    functions: {
        [key: string]: (...args: any[]) => Promise<any>;
    };
    interface: Contract['interface'];
}
/**
 * A standard gasless MetaTransaction ("force" in dApp)
 *
 * You can then `send` the transaction, wait for it to be `mined` or `encode` it.
 * See also https://docs.colony.io/colonysdk/guides/transactions for more information
 *
 * @example
 * ```typescript
 * (async function() {
 *   // Just send off the transaction and get back the tx object
 *   // First tupel value is the ethers transaction, including the hash
 *   // Second tupel value is a function that does the same as `.mined()` below
 *   const [tx, mined] = await colony.claimFunds().metaTx().send();
 *   console.info(tx.hash); // Transaction hash
 *   const [eventData, receipt] = await mined();
 *   // Wait for tx to be mined, get back the eventData, receipt
 *   const [eventData, receipt] = await colony.claimFunds().metaTx().mined();
 * })();
 * ```
 *
 * @returns A transaction that can be `send`, `mined` or `encode`d.
 */
export interface ColonyMetaTransaction<C extends TransactionResponse, E extends EventData | VotingReputationEvents.MotionCreatedEventObject, R extends ParsedLogTransactionReceipt, MD extends MetadataType> {
    /**
     * Send off the tx, returning the transaction including its hash, not waiting for it to be mined
     *
     * @returns A tupel of a contract transaction and a function to wait for the mined event data as well as the receipt
     */
    send(): Promise<[
        C,
        () => Promise<[E, R, () => Promise<MetadataTypeMap[MD]>] | [E, R]>
    ]>;
    /**
     * Wait until the tx is mined, returning the event data and the receipt
     *
     * @returns A tupel of event data and contract receipt (and a function to retrieve metadata if applicable)
     */
    mined(): Promise<[E, R, () => Promise<MetadataTypeMap[MD]>] | [E, R]>;
}
/**
 * A standard transaction ("force" in dApp)
 *
 * You can then `send` the transaction, wait for it to be `mined` or `encode` it.
 * See also https://docs.colony.io/colonysdk/guides/transactions for more information
 *
 * @example
 * ```typescript
 * (async function() {
 *   // Just send off the transaction and get back the tx object
 *   // First tupel value is the ethers transaction, including the hash
 *   // Second tupel value is a function that does the same as `.mined()` below
 *   const [tx, mined] = await colony.claimFunds().tx().send();
 *   console.info(tx.hash); // Transaction hash
 *   const [eventData, receipt] = await mined();
 *   // Wait for tx to be mined, get back the eventData, receipt
 *   const [eventData, receipt] = await colony.claimFunds().tx().mined();
 *   // A transaction can also be output as a raw, encoded string for later use (e.g. using `sendRawTransaction`)
 *   const encoded = await colony.claimFunds().tx().encode();
 *   console.log(encoded); // 0x89224a1e000000000000000000000000bdc38a08548b47015f5fe853aa6614cfb2cbfcc0
 * })();
 * ```
 *
 *
 * @returns A transaction that can be `send`, `mined` or `encode`d.
 */
export interface ColonyTransaction<C extends ContractTransaction, E extends EventData | VotingReputationEvents.MotionCreatedEventObject, R extends ContractReceipt, MD extends MetadataType> {
    /**
     * Send off the tx, returning the transaction including its hash, not waiting for it to be mined
     *
     * @returns A tupel of a contract transaction and a function to wait for the mined event data as well as the receipt
     */
    send(): Promise<[
        C,
        () => Promise<[E, R, () => Promise<MetadataTypeMap[MD]>] | [E, R]>
    ]>;
    /**
     * Wait until the tx is mined, returning the event data and the receipt
     *
     * @returns A tupel of event data and contract receipt (and a function to retrieve metadata if applicable)
     */
    mined(): Promise<[E, R, () => Promise<MetadataTypeMap[MD]>] | [E, R]>;
    /** Encode the transaction into a raw string
     *
     * @returns A raw, encoded transaction string
     */
    encode(): Promise<string>;
}
/**
 * An umbrella API for all kinds of transactions
 *
 * The `TxCreator` allows for a simple API to cover all the different cases of transactions within the Colony Network. This is the base class of the TxCreator that only supports the `tx()` action and no metatransactions.
 *
 * ## Create a standard transaction ("force" in dApp)
 *
 * - {@link TxCreator.tx}: force a Colony transaction, knowing you have the permissions to do so
 *
 * Learn more about these functions in their individual documentation
 */
export declare class TxCreator<C extends BaseContract, M extends keyof C['functions'], E extends EventData, MD extends MetadataType> {
    protected contract: C;
    protected config: ContractConfig;
    protected method: string;
    protected args: unknown[] | (() => Promise<unknown[]>);
    private eventData?;
    protected txConfig?: TxConfig<MD>;
    constructor({ contract, config, method, args, eventData, txConfig, }: {
        contract: C;
        config: ContractConfig;
        method: M;
        args: unknown[] | (() => Promise<unknown[]>);
        eventData?: (receipt: ContractReceipt) => Promise<E>;
        metadataType?: MD;
        txConfig?: TxConfig<MD>;
    });
    protected getArgs(overrides?: TxOverrides): Promise<unknown[]>;
    private getTx;
    private getMined;
    protected getEventData<R extends ContractReceipt | ParsedLogTransactionReceipt>(receipt: R): Promise<[E, R, () => Promise<MetadataTypeMap[MD]>] | [E, R]>;
    protected broadcastMetaTx(broadcastData: Record<string, unknown>): Promise<TransactionResponse>;
    protected waitForMetaTx(tx: TransactionResponse): Promise<ParsedLogTransactionReceipt>;
    /**
     * Create a standard transaction ("force" in dApp)
     *
     * See also {@link ColonyTransaction} or https://docs.colony.io/colonysdk/guides/transactions for more information
     *
     * @remarks The user sending this transaction has to have the appropriate permissions to do so. Learn more about permissions in Colony [here](/develop/dev-learning/permissions).
     *
     * @returns A transaction that can be `send`, `mined` or `encode`d.
     */
    tx(): ColonyTransaction<ContractTransaction, E, ContractReceipt, MD>;
}
