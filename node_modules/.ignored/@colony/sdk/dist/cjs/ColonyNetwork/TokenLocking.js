"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenLocking = void 0;
const tokens_1 = require("@colony/tokens");
const utils_js_1 = require("../utils.js");
class TokenLocking {
    constructor(colonyNetwork, address) {
        this.address = address;
        this.colonyNetwork = colonyNetwork;
        this.tokenLockingContract = (0, tokens_1.getTokenLockingClient)(this.address, colonyNetwork.config.signerOrProvider);
    }
    /**
     * Provide direct access to the internally used TokenLocking contract. Only use when you know what you're doing
     *
     * @internal
     * @returns The internally used TokenLockingContract
     */
    getInternalTokenLockingContract() {
        return this.tokenLockingContract;
    }
    /**
     * Deposit `amount` of the wallet owners holdings of the Colony's native token into the Colony.
     *
     * In order for the wallet owner to stake tokens, that amount has to be approved and deposited into the Colony first. In the dapp the process is called "Activation" of a certain amount of the Colony's native token. The wallet must hold at least the amount of the token that will be deposited.
     *
     * @example
     * ```typescript
     * import { w } from '@colony/sdk';
     *
     * // Immediately executing async function
     * (async function() {
     *   const token = await colony.getToken();
     *   // Approve 100 tokens for the Colony Network to activate
     *   await token.approve(w`100`).tx().mined();
     *   // Deposit the tokens
     *   await colonyNetwork.locking.deposit(token.address, w`100`).tx().mined();
     * })();
     * ```
     *
     * @param tokenAddress - Token to be deposited
     * @param amount - Amount of the token to be deposited
     *
     * @returns A transaction creator
     *
     * #### Event data
     *
     * | Property | Type | Description |
     * | :------ | :------ | :------ |
     * | `token` | string | The address of the Colony's native token |
     * | `user` | string | The address that deposited the tokens from their wallet |
     * | `amount` | BigNumber | Amount that was deposited |
     */
    deposit(tokenAddress, amount) {
        return this.colonyNetwork.createMetaTxCreator(this.tokenLockingContract, 'deposit(address,uint256,bool)', [tokenAddress, amount, false], (receipt) => __awaiter(this, void 0, void 0, function* () {
            return (Object.assign({}, (0, utils_js_1.extractEvent)('UserTokenDeposited', receipt)));
        }));
    }
    /**
     * Withdraw `amount` of the wallet owners holdings of the Colony's native token from the Colony.
     *
     * Does the opposite of `deposit` and frees the deposited tokens back to the wallet address.
     *
     * @example
     * ```typescript
     * import { w } from '@colony/sdk';
     *
     * // Immediately executing async function
     * (async function() {
     *   const token = await colony.getToken();
     *   // Withdraw 100 tokens that were previously deposited
     *   await colonyNetwork.locking.withdraw(token.address, w`100`).tx().mined();
     * })();
     * ```
     *
     * @param tokenAddress - Token to be withdrawn
     * @param amount - Amount of the token to be withdrawn
     *
     * @returns A transaction creator
     *
     * #### Event data
     *
     * | Property | Type | Description |
     * | :------ | :------ | :------ |
     * | `token` | string | The address of the Colony's native token |
     * | `user` | string | The address that withdrew the tokens from their wallet |
     * | `amount` | BigNumber | Amount that was withdrawn |
     */
    withdraw(tokenAddress, amount) {
        return this.colonyNetwork.createMetaTxCreator(this.tokenLockingContract, 'withdraw(address,uint256,bool)', [tokenAddress, amount, false], (receipt) => __awaiter(this, void 0, void 0, function* () {
            return (Object.assign({}, (0, utils_js_1.extractEvent)('UserTokenWithdrawn', receipt)));
        }));
    }
    /**
     * Get the wallet owner's deposited and locked balance of the Colony's native token.
     *
     * This method will show the accumulated amount that was deposited using the {@link deposit} method
     *
     * @param tokenAddress - Token to check
     * @param user - The wallet address that we want to check the deposited amount of
     *
     * @returns The currently deposited balance of the Colony's native token
     */
    getUserDeposit(tokenAddress, user) {
        return __awaiter(this, void 0, void 0, function* () {
            const userLock = yield this.tokenLockingContract.getUserLock(tokenAddress, user);
            return userLock.balance;
        });
    }
    /**
     * Get the wallet owner's approved balance of the Colony's native token for an obliator (i.e. an extension)
     *
     * This method will show the accumulated amount that was approved using the {@link ColonyToken.approve} method
     *
     * @param tokenAddress - Token to check
     * @param user - The wallet address that we want to check the approved amount of
     * @param obligator - The address that has been approved to obligate the funds.
     *
     * @returns The currently approved balance of the Colony's native token for the obligator
     */
    getUserApproval(tokenAddress, user, obligator) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.tokenLockingContract.getApproval(user, tokenAddress, obligator);
        });
    }
}
exports.TokenLocking = TokenLocking;
