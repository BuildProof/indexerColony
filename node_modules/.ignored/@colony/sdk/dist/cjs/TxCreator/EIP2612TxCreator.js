"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EIP2612TxCreator = void 0;
const ethers_1 = require("ethers");
const core_1 = require("@colony/core");
const TxCreator_js_1 = require("./TxCreator.js");
const { splitSignature } = ethers_1.utils;
/**
 * Create transactions for contracts supporting the EIP2612 standard
 *
 * The `EIP2612TxCreator` allows for a simple API to cover all the different cases of transactions within the Colony Network.
 *
 * ## Create a standard transaction ("permissions" in dApp)
 *
 * - [[EIP2612TxCreator.tx]]: force a Colony transaction, knowing you have the permissions to do so
 * - [[EIP2612TxCreator.metaTx]]: same as `tx()`, but send as a gasless metatransaction
 *
 * Learn more about these functions in their individual documentation
 */
class EIP2612TxCreator extends TxCreator_js_1.TxCreator {
    getMetaTx() {
        return __awaiter(this, void 0, void 0, function* () {
            const args = yield this.getArgs();
            return this.sendMetaTransaction(this.contract.address, args);
        });
    }
    getMetaMined(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            const receipt = yield this.waitForMetaTx(tx);
            return this.getEventData(receipt);
        });
    }
    sendMetaTransaction(target, [spender, amount]) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.config.metaTxBroadcasterEndpoint) {
                throw new Error(`No metatransaction broadcaster endpoint found for network ${this.config.network}`);
            }
            const signer = this.contract.signer;
            const { provider } = signer;
            if (!provider) {
                throw new Error('No provider found');
            }
            let chainId;
            if (this.config.network === core_1.Network.Custom) {
                chainId = 1;
            }
            else {
                const networkInfo = yield provider.getNetwork();
                chainId = networkInfo.chainId;
            }
            const userAddress = yield signer.getAddress();
            const nonce = yield this.contract.functions.nonces(userAddress);
            const tokenName = yield this.contract.name();
            /*
             * @NOTE One hour in the future from now
             * Time is in seconds
             */
            const deadline = Math.floor(Date.now() / 1000) + 3600;
            // eslint-disable-next-line no-underscore-dangle
            const signature = yield signer._signTypedData({
                name: tokenName,
                version: '1',
                chainId,
                verifyingContract: this.contract.address,
            }, {
                Permit: [
                    { name: 'owner', type: 'address' },
                    { name: 'spender', type: 'address' },
                    { name: 'value', type: 'uint256' },
                    { name: 'nonce', type: 'uint256' },
                    { name: 'deadline', type: 'uint256' },
                ],
            }, {
                owner: userAddress,
                spender,
                value: amount,
                nonce: nonce.toString(),
                deadline,
            });
            const { r, s, v } = splitSignature(signature);
            const broadcastData = {
                target,
                owner: userAddress,
                spender,
                value: amount.toString(),
                deadline,
                r,
                s,
                v,
            };
            return this.broadcastMetaTx(broadcastData);
        });
    }
    /**
     * Create a standard transaction ("force" in dApp)
     *
     * You can then `send` the transaction or wait for it to be `mined`.
     * See also https://docs.colony.io/colonysdk/guides/transactions for more information
     *
     * @remarks The user sending this transaction has to have the appropriate permissions to do so. Learn more about permissions in Colony [here](/develop/dev-learning/permissions).
     *
     * @returns A transaction that can be `send`, `mined` or `encode`d.
     */
    tx() {
        if (this.method === 'permit') {
            throw new Error(`Only MetaTransactions are supported for this method. Please use "approve" instead.`);
        }
        return super.tx.apply(this);
    }
    /**
     * Create a gasless MetaTransaction ("force" in dApp)
     *
     * After creation, you can then `send` the transaction or wait for it to be `mined`.
     * See also [[TxCreator.tx]] and https://docs.colony.io/colonysdk/guides/transactions for more information
     *
     * @remarks The user sending this transaction has to have the appropriate permissions to do so. Learn more about permissions in Colony [here](/develop/dev-learning/permissions).
     *
     * @returns A transaction that can be `send` or `mined`.
     */
    metaTx() {
        if (this.method !== 'permit') {
            throw new Error(`Only the "permit" function is allowed to be sent as MetaTransaction per EIP-2612`);
        }
        return {
            send: () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield this.getMetaTx();
                return [tx, this.getMetaMined.bind(this, tx)];
            }),
            mined: () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield this.getMetaTx();
                return this.getMetaMined(tx);
            }),
        };
    }
}
exports.EIP2612TxCreator = EIP2612TxCreator;
