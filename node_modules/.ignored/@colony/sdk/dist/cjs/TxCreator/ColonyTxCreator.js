"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ColonyTxCreator = void 0;
const core_1 = require("@colony/core");
const utils_js_1 = require("../utils.js");
const MetaTxCreator_js_1 = require("./MetaTxCreator.js");
/**
 * An umbrella API for all kinds of transactions within colonies
 *
 * The `ColonyTxCreator` allows for a simple API to cover all the different cases of transactions within a colony. Once a `ColonyTxCreator` is created using a method on the base contracts (e.g. {@link Colony} or extensions like {@link VotingReputation}) there are four options available:
 *
 * ## Create a standard transaction ("force" in dApp)
 *
 * - {@link ColonyTxCreator.tx}: force a Colony transaction, knowing you have the permissions to do so
 * - {@link ColonyTxCreator.metaTx}: same as `tx()`, but send as a gasless metatransaction
 *
 * ## Create a motion to trigger an action once it passes
 *
 * - {@link ColonyTxCreator.motion}: create a motion (needs the motion's domain as a parameter)
 * - {@link ColonyTxCreator.metaMotion}: same as `motion()`, but sends a gasless metatransaction
 *
 * Learn more about these functions in their individual documentation
 */
class ColonyTxCreator extends MetaTxCreator_js_1.MetaTxCreator {
    constructor(config) {
        super(config);
        this.colony = config.colony;
        this.permissionConfig = config.permissionConfig;
    }
    getMotionTx(motionDomain) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.colony) {
                throw new Error('Motions can only be created on a Colony');
            }
            if (!this.colony.ext.motions) {
                throw new Error('VotingReputation extension is not installed for this Colony');
            }
            const args = yield this.getArgs();
            const encodedAction = this.contract.interface.encodeFunctionData(this.method, args);
            // If the contract for this TxCreator is the colony, use 0x0, otherwise use the extension's address
            const altTarget = this.contract.address === this.colony.address
                ? '0x0'
                : this.contract.address;
            const { actionCid, key, value, branchMask, siblings } = yield (0, core_1.getCreateMotionProofs)(this.colony.colonyNetwork.getInternalNetworkContract(), this.colony.getInternalColonyContract(), this.colony.reputation, this.colony.ext.motions.getInternalVotingReputationContract(), motionDomain, altTarget, encodedAction);
            return this.colony.ext.motions
                .getInternalVotingReputationContract()
                .createMotion(motionDomain, actionCid, altTarget, encodedAction, key, value, branchMask, siblings);
        });
    }
    // eslint-disable-next-line class-methods-use-this
    getMotionMined(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            const receipt = yield tx.wait();
            const data = Object.assign({}, (0, utils_js_1.extractEvent)('MotionCreated', receipt));
            return [data, receipt];
        });
    }
    getEncodedMotionTx(motionDomain) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.colony) {
                throw new Error('Motions can only be created on a Colony');
            }
            if (!this.colony.ext.motions) {
                throw new Error('VotingReputation extension is not installed for this Colony');
            }
            const args = yield this.getArgs();
            const encodedAction = this.contract.interface.encodeFunctionData(this.method, args);
            // If the contract for this TxCreator is the colony, use 0x0, otherwise use the extension's address
            const altTarget = this.contract.address === this.colony.address
                ? '0x0'
                : this.contract.address;
            const votingReputationClient = this.colony.ext.motions.getInternalVotingReputationContract();
            const { actionCid, key, value, branchMask, siblings } = yield (0, core_1.getCreateMotionProofs)(this.colony.colonyNetwork.getInternalNetworkContract(), this.colony.getInternalColonyContract(), this.colony.reputation, this.colony.ext.motions.getInternalVotingReputationContract(), motionDomain, altTarget, encodedAction);
            return [
                votingReputationClient.interface.encodeFunctionData('createMotion', [
                    motionDomain,
                    actionCid,
                    altTarget,
                    encodedAction,
                    key,
                    value,
                    branchMask,
                    siblings,
                ]),
                votingReputationClient.address,
            ];
        });
    }
    getMetaMotionTx(motionDomain) {
        return __awaiter(this, void 0, void 0, function* () {
            const [encodedTransaction, address] = yield this.getEncodedMotionTx(motionDomain);
            return this.sendMetaTransaction(encodedTransaction, address);
        });
    }
    getMetaMotionMinded(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            const receipt = yield this.waitForMetaTx(tx);
            const data = Object.assign({}, (0, utils_js_1.extractEvent)('MotionCreated', receipt));
            return [data, receipt];
        });
    }
    getArgs() {
        return __awaiter(this, void 0, void 0, function* () {
            let args = [];
            if (typeof this.args == 'function') {
                args = yield this.args();
            }
            else {
                args = this.args;
            }
            if (this.permissionConfig) {
                if (!this.colony) {
                    throw new Error('Permissioned transactions can only be created on a Colony');
                }
                const [permissionDomainId, childSkillIndex] = yield (0, core_1.getPermissionProofs)(this.colony.colonyNetwork.getInternalNetworkContract(), this.colony.getInternalColonyContract(), this.permissionConfig.domain, this.permissionConfig.roles, this.permissionConfig.address);
                // Quite dangerous but probably fine. Plus, it gets TS off our backs ;)
                args.unshift(permissionDomainId, childSkillIndex);
            }
            return args;
        });
    }
    /**
     * Creates a motion for an action
     *
     * You can specify a team (domain) this motion should be created in. It will be created in the Root team by default.
     *
     * After creation, you can then `send` the transaction or wait for it to be `mined`.
     * See also {@link ColonyTransaction} and https://docs.colony.io/colonysdk/guides/transactions for more information
     *
     * @remarks This will only work if the {@link VotingReputation} extension is installed for the Colony that's being acted on
     *
     * @returns A motion transaction that can be `send` or `mined` or `encode`d.
     */
    motion(motionDomain = core_1.Id.RootDomain) {
        return {
            send: () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield this.getMotionTx(motionDomain);
                return [tx, this.getMotionMined.bind(this, tx)];
            }),
            mined: () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield this.getMotionTx(motionDomain);
                return this.getMotionMined(tx);
            }),
            encode: () => __awaiter(this, void 0, void 0, function* () {
                const [encoded] = yield this.getEncodedMotionTx(motionDomain);
                return encoded;
            }),
        };
    }
    /**
     * Creates a motion for an action, using a gasless transaction
     *
     * You can specify a team (domain) this motion should be created in. It will be created in the Root team by default.
     *
     * After creation, you can then `send` the transaction or wait for it to be `mined`.
     * See also {@link TxCreator.tx} and https://docs.colony.io/colonysdk/guides/transactions for more information
     *
     * @remarks This will only work if the {@link VotingReputation} extension is installed for the Colony that's being acted on
     *
     * @returns A motion transaction that can be `send` or `mined` or `encode`d.
     */
    metaMotion(motionDomain = core_1.Id.RootDomain) {
        return {
            send: () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield this.getMetaMotionTx(motionDomain);
                return [tx, this.getMetaMotionMinded.bind(this, tx)];
            }),
            mined: () => __awaiter(this, void 0, void 0, function* () {
                const tx = yield this.getMetaMotionTx(motionDomain);
                return this.getMetaMotionMinded(tx);
            }),
        };
    }
}
exports.ColonyTxCreator = ColonyTxCreator;
