import { constants, utils, } from 'ethers';
import { ColonyLabelSuffix, UserLabelSuffix, ColonyNetworkAddress, } from '@colony/core';
import { MetadataType, } from '@colony/events';
import { IColonyNetwork__factory as IColonyNetworkFactory, } from '../contracts/index.js';
import { TxCreator, MetaTxCreator, } from '../TxCreator/index.js';
import { Colony } from './Colony.js';
import { extractEvent } from '../utils.js';
import { EIP2612TxCreator } from '../TxCreator/EIP2612TxCreator.js';
import { TokenLocking } from './TokenLocking.js';
import { ContractConfig } from '../ContractConfig.js';
const { namehash } = utils;
const { AddressZero } = constants;
export class ColonyNetwork {
    contract;
    locking;
    /** Configuration of the ColonyNetwork for later use */
    /** @internal */
    config;
    /**
     * Creates a new instance of the ColonyNetwork
     *
     * This is your main entry point to talk to the Colony Network Smart Contracts.
     * From here you should be able to instantiate all the required instances for Colonies and their extensions.
     *
     * @example
     *
     * ```typescript
     * import { providers } from 'ethers';
     * import { ColonyNetwork, ColonyRpcEndpoint, Tokens } from '@colony/sdk';
     *
     * // Connect directly to the deployed Colony Network on Arbitrum One
     * const provider = new providers.JsonRpcProvider(ColonyRpcEndpoint.ArbitrumOne);
     * const colonyNetwork = new ColonyNetwork(provider);
     * // Now you could call functions on the colonyNetwork, like `colonyNetwork.getMetaColony()`
     * ```
     *
     * @param signerOrProvider - An _ethers_ compatible Signer or Provider instance
     * @param options - Optional custom {@link ColonyNetworkOptions}
     * @returns A ColonyNetwork abstraction instance
     */
    constructor(signerOrProvider, options) {
        this.config = new ContractConfig(signerOrProvider, options);
        this.contract = IColonyNetworkFactory.connect(options?.customNetworkAddress ||
            ColonyNetworkAddress[this.config.network], signerOrProvider);
    }
    /**
     * Fetches the TokenLocking client abstraction
     *
     * @returns A {@link TokenLocking} contract client
     */
    async getTokenLocking() {
        if (!this.locking) {
            const address = await this.contract.getTokenLocking();
            this.locking = new TokenLocking(this, address);
        }
        return this.locking;
    }
    /**
     * Provide direct access to the internally used ethers Contract. Only use when you know what you're doing
     *
     * @internal
     * @returns The internally used ethers Contract
     */
    getInternalNetworkContract() {
        return this.contract;
    }
    /**
     * Creates a new {@link TxCreator} for non-meta, non-motion transactions
     * @internal
     *
     * @remarks
     * Do not use this method directly but rather the class methods in the Colony or extensions
     *
     * @param contract - A ColonyJS contract
     * @param method - The transaction method to execute on the contract
     * @param args - The arguments for the method
     * @param eventData - A function that extracts the relevant event data from the {@link ContractReceipt}
     * @param txConfig - More configuration options, like {@link MetadataType} if the event contains metadata or if methods are unsupported
     * @returns A {@link TxCreator}
     */
    createTxCreator(contract, method, args, eventData, txConfig) {
        return new TxCreator({
            config: this.config,
            contract,
            method,
            args,
            eventData,
            txConfig,
        });
    }
    /**
     * Creates a new {@link MetaTxCreator} for possibly meta, non-motion transactions
     * @internal
     *
     * @remarks
     * Do not use this method directly but rather the class methods in the Colony or extensions
     *
     * @param contract - A ColonyJS contract
     * @param method - The transaction method to execute on the contract
     * @param args - The arguments for the method
     * @param eventData - A function that extracts the relevant event data from the {@link ContractReceipt}
     * @param txConfig - More configuration options, like {@link MetadataType} if the event contains metadata or if methods are unsupported
     * @returns A {@link MetaTxCreator}
     */
    createMetaTxCreator(contract, method, args, eventData, txConfig) {
        return new MetaTxCreator({
            config: this.config,
            contract,
            method,
            args,
            eventData,
            txConfig,
        });
    }
    /**
     * Creates a new {@link EIP2612TxCreator} for EIP-2612 transactions (permit)
     * @internal
     *
     * @remarks
     * Do not use this method directly but rather the class methods in the Colony or extensions
     *
     * @param contract - Only a EIP-2612 compatible token contract
     * @param method - Can only do 'permit'
     * @param args - The arguments for the 'permit' method
     * @param eventData - A function that extracts the relevant event data from the {@link ContractReceipt}
     * @param txConfig - More configuration options, like {@link MetadataType} if the event contains metadata or if methods are unsupported
     * @returns A {@link EIP2612TxCreator}
     */
    createEip2612TxCreator(contract, method, args, eventData, txConfig) {
        return new EIP2612TxCreator({
            config: this.config,
            contract,
            method,
            args,
            eventData,
            txConfig,
        });
    }
    createColony(token, label, metadata) {
        const prepareArgs = async () => {
            const existingAddress = await this.getColonyAddress(label);
            if (existingAddress) {
                throw new Error(`Colony with label ${label} already exists`);
            }
            // TODO: check all arguments for existance
            if (typeof token != 'string') {
                if (!token.name) {
                    throw new Error('Token name is required');
                }
                if (!token.symbol) {
                    throw new Error('Token symbol is required');
                }
                // TODO: check decimals type
                return [
                    AddressZero,
                    token.name,
                    token.symbol,
                    token.decimals || 18,
                    0,
                    label,
                    '',
                ];
            }
            return [token, '', '', 0, 0, label, ''];
        };
        if (!metadata) {
            return this.createMetaTxCreator(this.contract, 'createColonyForFrontend', prepareArgs, async (receipt) => ({
                ...extractEvent('TokenDeployed', receipt),
                ...extractEvent('ColonyAdded', receipt),
                // eslint-disable-next-line max-len
                ...extractEvent('TokenAuthorityDeployed', receipt),
            }));
        }
        return this.createMetaTxCreator(this.contract, 'createColonyForFrontend', async () => {
            const args = await prepareArgs();
            if (typeof metadata == 'string') {
                args[6] = metadata;
            }
            else {
                args[6] = await this.config.ipfs.uploadMetadata(MetadataType.Colony, metadata);
            }
            return args;
        }, async (receipt) => ({
            ...extractEvent('TokenDeployed', receipt),
            ...extractEvent('ColonyAdded', receipt),
            ...extractEvent('TokenAuthorityDeployed', receipt),
        }), {
            metadataType: MetadataType.Colony,
        });
    }
    /**
     * Get a new instance of a Colony
     *
     * Use this function to instantiate a new `Colony` by providing the Colony's address
     *
     * @remarks
     * Colony contracts are versioned. If the deployed Colony version does not match the supported version an error will be thrown
     *
     * @param address - The Colony's address
     * @returns A Colony abstaction instance
     */
    async getColony(address) {
        return Colony.connect(this, address);
    }
    /**
     * Get a new instance of the MetaColony
     *
     * Use this function to instantiate a new `Colony` for the deployed MetaColony
     *
     * @returns A Colony abstaction instance of the MetaColony
     */
    async getMetaColony() {
        const colonyAddress = await this.contract.getMetaColony();
        return this.getColony(colonyAddress);
    }
    /**
     * Get the colony's ENS label
     *
     * Returns the colony's ENS label, just like it's shown in the browsers address bar after `/colony/`, when using the dApp.
     * Will return `null` if the colony does not exist or if no label was assigned yet
     *
     * @returns The colony's ENS label
     */
    async getColonyLabel(address) {
        const ensName = await this.contract.lookupRegisteredENSDomain(address);
        if (ensName) {
            return ensName.replace(ColonyLabelSuffix[this.config.network], '');
        }
        return null;
    }
    /**
     * Get the colony's addess by the ENS label
     *
     * Returns the colony's address that belongs to the given ENS label
     * Will return `null` if the given label was not assigned to a colony.
     *
     * @returns The colony's address
     */
    async getColonyAddress(label) {
        const hash = namehash(`${label}${ColonyLabelSuffix[this.config.network]}`);
        const address = await this.contract.addr(hash);
        if (address !== AddressZero) {
            return address;
        }
        return null;
    }
    /**
     * Get a user's username
     *
     * Returns the user's username (the ENS label, just like it's shown in the dapp, without any suffixes)
     * Will return `null` if the user does not exist or if no label was assigned yet
     *
     * @returns The user's username
     */
    async getUsername(address) {
        const ensName = await this.contract.lookupRegisteredENSDomain(address);
        if (ensName) {
            return ensName.replace(UserLabelSuffix[this.config.network], '');
        }
        return null;
    }
    /**
     * Get the user's addess by the username
     *
     * Returns the user's address that belongs to the given username. Username has to be provided without any suffix, just like it's shown in the dapp.
     * Will return `null` if the given username was not registered.
     *
     * @returns The user's address
     */
    async getUserAddress(username) {
        const hash = namehash(`${username}${UserLabelSuffix[this.config.network]}`);
        const address = await this.contract.addr(hash);
        if (address !== AddressZero) {
            return address;
        }
        return null;
    }
    /**
     * Register a Colony-internal ENS username
     *
     * Registers a username for the signing address. An address can only register one username. Usernames are globally unique. This method will check whether the username was registered before.
     *
     * @returns A transaction creator
     */
    registerUsername(username) {
        const checkUsername = async () => {
            const existingAddress = await this.getColonyAddress(username);
            if (existingAddress) {
                throw new Error(`Username ${username} is already taken`);
            }
            return [username, ''];
        };
        return this.createMetaTxCreator(this.contract, 'registerUserLabel', checkUsername, async (receipt) => ({
            ...extractEvent('UserLabelRegistered', receipt),
        }));
    }
    /**
     * Deploy a "special" Colony ERC20 token
     *
     * If there is not token yet that should be used with the Colony, this is the canonical way to create one.
     *
     * This is a supercharged ERC20 token contract, that not only has a permissioned `mint` function (that can be used from the colony) but also supports Metatransactions. In order to fully use its permissioned system with a Colony, some extra steps have to be taken. See the [Colony Creation Guide](../../guides/colony-creation.md).
     *
     * @remarks
     * The token deployed with this function is locked by default. Call `unlockToken()` on the Colony at a later point to unlock it.
     *
     * @returns A transaction creator
     */
    deployToken(name, symbol, decimals = 18) {
        return this.createMetaTxCreator(this.contract, 'deployTokenViaNetwork', [name, symbol, decimals], async (receipt) => ({
            ...extractEvent('TokenDeployed', receipt),
        }));
    }
}
