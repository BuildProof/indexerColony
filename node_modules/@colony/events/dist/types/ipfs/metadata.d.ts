import type { DataTypeMap, MetadataTypeMap } from './types.js';
import { MetadataType } from './constants.js';
/**
 * Parses and validates event metadata
 *
 * This will check the validity of an event metadata object.
 * You can pass in an optional type if you know what to expect.
 * It will also do a data version check.
 *
 * If you don't know what the output will be you can use TypeScript's
 * Discriminated Unions to guard the correct types (see example).
 *
 * @example
 * ```typescript
 * import { parseEventMetadata, MetadataType } from '@colony/event-metadata';
 *
 * // Get `input` from IPFS or other sources.
 *
 * const result = parseEventMetadata(input);
 *
 * if (result.type === MetadataType.Domain) {
 *   // Type is DomainMetadata
 *   console.log(result.data.domainName);
 * }
 * ```
 *
 * @param input - JavaScript object (parsed, from IPFS)
 * @param type - Optional MetadataType to check against
 *
 * @returns The validated Metadata.
 */
export declare const parseEventMetadata: <T extends MetadataType = MetadataType.DEFAULT>(input: object, type?: T) => MetadataTypeMap[T];
/**
 * Get the version of a Metadata object
 *
 * Defaults to 1.
 *
 * @param input - JavaScript object (parsed, from IPFS)
 *
 * @returns The version number of the metadata
 */
export declare const getEventMetadataVersion: (input: object) => number;
/**
 * Create a valid Metadata object.
 *
 * Validates the input.
 *
 * @example
 * ```typescript
 * import { createMetadataFor, MetadataType } from '@colony/event-metadata';
 *
 * const result = createMetadataFor(MetadataType.Domain, {
 *   domainName: 'Cool team',
 * });
 *
 * console.log(result.version); // 2
 * console.log(result.name); // 'domain'
 * console.log(result.data.domainName); // 'Cool team'
 * ```
 *
 * @param type - The metadata type
 * @param data - The actual data for the generated metadata object
 *
 * @returns The version number of the metadata
 */
export declare const createMetadataFor: <T extends MetadataType>(type: T, data: DataTypeMap[T]) => MetadataTypeMap[T];
