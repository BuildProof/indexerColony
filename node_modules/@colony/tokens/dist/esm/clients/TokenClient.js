import { constants } from 'ethers';
import { ClientType, TokenClientType } from '../constants.js';
import { MetaTxToken__factory as MetaTxTokenFactory, } from '../contracts/index.js';
import { TokenERC20__factory as TokenERC20Factory, TokenERC2612__factory as TokenERC2612Factory, } from '../contracts/static/index.js';
const { AddressZero } = constants;
async function checkTokenAuthorityCompatibility(tokenClient) {
    try {
        await tokenClient.authority();
    }
    catch (e) {
        throw new Error('Token can not be assigned a TokenAuthority');
    }
}
const getTokenClient = async (address, signerOrProvider) => {
    let tokenClient;
    let isColonyToken = true;
    let isEip2612Token = true;
    tokenClient = MetaTxTokenFactory.connect(address, signerOrProvider);
    try {
        await tokenClient.totalSupply();
    }
    catch (err) {
        throw new Error(`Token is probably not a valid ERC20 token, got ${err.message}`);
    }
    // Colony tokens have the `locked()` and `authority()` methods. We assume that when it exists on
    // the contract we have a ColonyToken ðŸ¦†. This might not be true though, so can't rely
    // on this 100% when trying to call contract methods
    try {
        await tokenClient.locked();
        await checkTokenAuthorityCompatibility(tokenClient);
    }
    catch {
        isColonyToken = false;
    }
    try {
        // NOTE: Casting will be unnecessary when MetaTxToken supports "nonces"
        await tokenClient.nonces(AddressZero);
    }
    catch {
        isEip2612Token = false;
    }
    // NOTE: The following is horrible. But that's just how things are with tokens rn.
    if (isColonyToken) {
        tokenClient.tokenClientType = TokenClientType.Colony;
    }
    else if (isEip2612Token) {
        tokenClient = TokenERC2612Factory.connect(address, signerOrProvider);
        tokenClient.tokenClientType = TokenClientType.Erc2612;
    }
    else {
        tokenClient = TokenERC20Factory.connect(address, signerOrProvider);
        tokenClient.tokenClientType = TokenClientType.Erc20;
    }
    tokenClient.clientType = ClientType.TokenClient;
    return tokenClient;
};
export default getTokenClient;
