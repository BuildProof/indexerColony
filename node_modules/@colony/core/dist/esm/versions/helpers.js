import { COLONY_VERSIONS } from './IColony.js';
import { assertExhaustiveSwitch } from '../utils/index.js';
import { fundingQueueIncompatibilityMap, } from './FundingQueue.js';
import { multisigPermissionsIncompatibilityMap, } from './MultisigPermissions.js';
import { oneTxPaymentIncompatibilityMap, } from './OneTxPayment.js';
import { reputationBootstrapperIncompatibilityMap, } from './ReputationBootstrapper.js';
import { stagedExpenditureIncompatibilityMap, } from './StagedExpenditure.js';
import { stakedExpenditureIncompatibilityMap, } from './StakedExpenditure.js';
import { streamingPaymentsIncompatibilityMap, } from './StreamingPayments.js';
import { tokenSupplierIncompatibilityMap, } from './TokenSupplier.js';
import { votingReputationIncompatibilityMap, } from './VotingReputation.js';
import { Extension } from '../constants.js';
const getExtensionIncompatibilityMap = (extension, extensionVersion) => {
    switch (extension) {
        case Extension.FundingQueue: {
            return fundingQueueIncompatibilityMap[extensionVersion];
        }
        case Extension.IVotingReputation: {
            return votingReputationIncompatibilityMap[extensionVersion];
        }
        case Extension.MultisigPermissions: {
            return multisigPermissionsIncompatibilityMap[extensionVersion];
        }
        case Extension.OneTxPayment: {
            return oneTxPaymentIncompatibilityMap[extensionVersion];
        }
        case Extension.ReputationBootstrapper: {
            return reputationBootstrapperIncompatibilityMap[extensionVersion];
        }
        case Extension.StagedExpenditure: {
            return stagedExpenditureIncompatibilityMap[extensionVersion];
        }
        case Extension.StakedExpenditure: {
            return stakedExpenditureIncompatibilityMap[extensionVersion];
        }
        case Extension.StreamingPayments: {
            return streamingPaymentsIncompatibilityMap[extensionVersion];
        }
        case Extension.TokenSupplier: {
            return tokenSupplierIncompatibilityMap[extensionVersion];
        }
        case Extension.VotingReputation: {
            return votingReputationIncompatibilityMap[extensionVersion];
        }
        default:
            return assertExhaustiveSwitch(extension, 'Could not find extension with name');
    }
};
/**
 * Checks the compatibility of an extension version with a colony version it requests to be installed in
 * Returns `true` if an extension version is compatible with the given colony version
 *
 * @param extension - A valid `Extension` contract name
 * @param extensionVersion - The version of the extension to check against the colony
 * @param colonyVersion - The version of the colony to check for
 *
 * @returns indication whether extension in given version is compatible with colony at the given version
 */
export const isExtensionCompatible = (extension, extensionVersion, colonyVersion) => {
    const map = getExtensionIncompatibilityMap(extension, extensionVersion);
    if (!map) {
        console.warn(`Version ${extensionVersion} of ${extension} is unknown. Compatibility check disabled`);
        return true;
    }
    return !map.includes(colonyVersion);
};
/**
 * Calculates and returns the lowest compatible colony version for a given version of an extension
 *
 * @param extension - A valid `Extension` contract name
 * @param extensionVersion - The version of the extension to check
 *
 * @returns the lowest compatible colony version for a given version of an extension
 */
export const getExtensionLowestCompatibleColonyVersion = (extension, extensionVersion) => {
    const map = getExtensionIncompatibilityMap(extension, extensionVersion);
    if (!map) {
        throw new Error(`Could not find incompatibility map for extension "${extension}" with version: ${extensionVersion}`);
    }
    if (!map.length) {
        return COLONY_VERSIONS[0];
    }
    const colonyVersion = COLONY_VERSIONS.find((v) => v === map[map.length - 1] + 1);
    if (colonyVersion === undefined || null) {
        throw new Error(`No compatible colony version found for extension "${extension}" with version: ${extensionVersion}`);
    }
    return colonyVersion;
};
