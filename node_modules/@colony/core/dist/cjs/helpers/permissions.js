"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPermissionProofs = exports.parsePermissionedAction = void 0;
const ethers_1 = require("ethers");
const constants_js_1 = require("../constants.js");
const network_js_1 = require("./network.js");
const { hexDataSlice } = ethers_1.utils;
const { MaxUint256 } = ethers_1.constants;
/*
 * Parses a permissioned action that is supposed to be executed (e.g. in a motion)
 *
 * The signature, as well as the domain in which the permission exists are returned
 *
 * @param action - Encoded action (an encoded transaction, essentially)
 *
 * @returns Signature, domain the permissions exists in and the index on the children array of the parent domain
 */
const parsePermissionedAction = (action) => {
    const sig = hexDataSlice(action, 0, 3);
    const permissionDomainId = ethers_1.BigNumber.from(hexDataSlice(action, 4, 35));
    const childSkillIndex = ethers_1.BigNumber.from(hexDataSlice(action, 36, 67));
    return { sig, permissionDomainId, childSkillIndex };
};
exports.parsePermissionedAction = parsePermissionedAction;
const getSinglePermissionProofs = (network, colony, domainId, role, customAddress) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const permissionAddress = customAddress || (yield ((_a = colony.signer) === null || _a === void 0 ? void 0 : _a.getAddress()));
    if (!permissionAddress) {
        throw new Error(`Could not determine address for permission proofs. Please use a signer or provide a custom address`);
    }
    const hasPermissionInDomain = yield colony.hasUserRole(permissionAddress, domainId, role);
    if (hasPermissionInDomain) {
        return [ethers_1.BigNumber.from(domainId), MaxUint256, permissionAddress];
    }
    // TODO: once we allow nested domains on the network level, this needs to traverse down the skill/domain tree. Use binary search
    const foundDomainId = ethers_1.BigNumber.from(constants_js_1.Id.RootDomain);
    const hasPermissionInAParentDomain = yield colony.hasUserRole(permissionAddress, foundDomainId, role);
    if (!hasPermissionInAParentDomain) {
        throw new Error(`${permissionAddress} does not have the permission ${role} in any parent domain`);
    }
    const idx = yield (0, network_js_1.getChildIndex)(network, colony, foundDomainId, domainId);
    if (idx.lt(0)) {
        throw new Error(`${permissionAddress} does not have the permission ${role} in any parent domain`);
    }
    return [foundDomainId, idx, permissionAddress];
});
const getMultiPermissionProofs = (network, colony, domainId, roles, customAddress) => __awaiter(void 0, void 0, void 0, function* () {
    const proofs = yield Promise.all(roles.map((role) => getSinglePermissionProofs(network, colony, domainId, role, customAddress)));
    // We are checking that all of the permissions resolve to the same domain and childSkillIndex
    for (let idx = 0; idx < proofs.length; idx += 1) {
        const [permissionDomainId, childSkillIndex, address] = proofs[idx];
        if (!permissionDomainId.eq(proofs[0][0]) ||
            !childSkillIndex.eq(proofs[0][1])) {
            throw new Error(`${address} has to have all required roles (${roles}) in the same domain`);
        }
    }
    // It does not need to be an array because if we get here, all the proofs are the same
    return proofs[0];
});
/**
 * Get the permission proofs for a user address and a certain role
 *
 * Certain methods on Colony contracts require so called "permission proofs". These are made up by
 * the `permissionDomainId` and the `childSkillIndex`. We shall attempt an explanation here.
 *
 * Domains within a colony can be nested and all the permissions in a parent domain apply for all child domains.
 * Yet at the time of calling a domain-permissioned method the contracts are unaware of the parent domain
 * a certain user has the required permission in. So when we these methods are called we have to supply them
 * the id of the parent domain the user has the permission in (it could also be the very same domain id they
 * want to act in!). Furthermore for the contracts the unidirectional chain downwards we have to supply
 * the method wuth the index of the domains associated skill in its parents children array
 * (`childSkillIndex`, see [[`getChildIndex`]]).
 * The contracts are then able to verify the permissions (the role) claimed by the caller.
 *
 * tl;dr:
 *
 * * `permissionDomainId`: id of the parent domain of the required domain the user has the required permission in
 * * `childSkillIndex`: the child index for a domain inside its corresponding skills parent children array
 *
 * @param client - Any ColonyClient
 * @param domainId - Domain id the method needs to act in
 * @param roles - Permissioning role(s) that the methods needs to function
 * @param customAddress - A custom address to get the permission proofs for (defaults to the signer's address)
 *
 * @returns Tuple of `[permissionDomainId, childSkillIndex, permissionAddress]`
 */
const getPermissionProofs = (network, colony, domainId, roles, customAddress) => __awaiter(void 0, void 0, void 0, function* () {
    if (Array.isArray(roles)) {
        if (roles.length === 1) {
            return (0, exports.getPermissionProofs)(network, colony, domainId, roles[0], customAddress);
        }
        return getMultiPermissionProofs(network, colony, domainId, roles, customAddress);
    }
    return getSinglePermissionProofs(network, colony, domainId, roles, customAddress);
});
exports.getPermissionProofs = getPermissionProofs;
