"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCreateMotionProofs = getCreateMotionProofs;
const ethers_1 = require("ethers");
const constants_js_1 = require("../constants.js");
const index_js_1 = require("../contracts/index.js");
const permissions_js_1 = require("./permissions.js");
const network_js_1 = require("./network.js");
const { MaxUint256 } = ethers_1.constants;
const { AddressZero } = ethers_1.constants;
function getCapabilityRolesAsArray(contract, _sig) {
    return __awaiter(this, void 0, void 0, function* () {
        let rolesHexString;
        try {
            // This will work if the target has the getCapabilityRoles method
            rolesHexString = yield contract.getCapabilityRoles(ethers_1.utils.hexZeroPad(_sig, 4));
            return (0, network_js_1.hex2ColonyRoles)(rolesHexString);
        }
        catch (e) {
            // Otherwise we assume that the encoded method is not permissioned
            return [];
        }
    });
}
/**
 * Gets the necessary proofs for motion creation
 *
 * This gets the reputation and domain proofs for motion creation
 *
 * @param contract - Any VotingReputation extension contract
 * @param domainId - Domain id the motion will be created in
 * @param altTarget - Target address for the motion (0x0 if Colony contract)
 * @param action - The encoded action the motion will execute when finalized
 *
 * @returns The necessary reputation and domain proofs to create a motion
 */
function getCreateMotionProofs(network, colony, reputation, votingReputation, domainId, altTarget, action) {
    return __awaiter(this, void 0, void 0, function* () {
        let actionCid;
        const { skillId } = yield colony.getDomain(domainId);
        const { sig, permissionDomainId, childSkillIndex } = (0, permissions_js_1.parsePermissionedAction)(action);
        const motionTarget = index_js_1.MotionTarget__factory.connect(altTarget, votingReputation.signer || votingReputation.provider);
        const capabilityRoles = yield getCapabilityRolesAsArray(motionTarget, sig);
        // Requires root or is not a permissioned function
        if (capabilityRoles.includes(constants_js_1.ColonyRole.Root) ||
            capabilityRoles.length === 0) {
            if (!ethers_1.BigNumber.from(domainId).eq(1)) {
                throw new Error(`On root or not permissioned actions, the domainId needs to be ${constants_js_1.Id.RootDomain}`);
            }
            // No permission proof needed
            actionCid = MaxUint256;
        }
        else {
            // Get associated skill of permissionDomainId of action
            const { skillId: permissionSkillId } = yield colony.getDomain(permissionDomainId);
            // Get the associated skill of the domain the action is taking place in
            const actionSkillId = yield network.getChildSkillId(permissionSkillId, childSkillIndex);
            // It's the same one, that's fine
            if (actionSkillId.eq(skillId)) {
                actionCid = MaxUint256;
            }
            else {
                // Find the relationship between the skill of the domain we want to create the motion in and the skill of the domain the action is taking place in
                const { children } = yield network.getSkill(skillId);
                const idx = children.findIndex((cid) => cid.eq(actionSkillId));
                if (idx < 0) {
                    throw new Error(`Could not find ${actionSkillId} as a child of ${skillId}`);
                }
                actionCid = ethers_1.BigNumber.from(idx);
            }
        }
        const { key, value, branchMask, siblings } = yield reputation.getReputationWithProofs(skillId, AddressZero);
        return {
            actionCid,
            key,
            value,
            branchMask,
            siblings,
        };
    });
}
