"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseLogs = exports.getContractVersion = exports.getBlockTime = exports.getPotDomain = exports.getExtensionHash = exports.getChildIndex = exports.hex2ColonyRoles = exports.colonyRoles2Hex = exports.w = exports.toWei = exports.toEth = exports.addressesAreEqual = void 0;
const ethers_1 = require("ethers");
const constants_js_1 = require("../constants.js");
const index_js_1 = require("../utils/index.js");
const index_js_2 = require("../contracts/index.js");
const { keccak256, toUtf8Bytes } = ethers_1.utils;
const { MaxUint256 } = ethers_1.constants;
/**
 * Check if two addresses are equal
 *
 * Addresses can be displayed using a checksum format which contains uppercase and lowercase characters.
 * This function can compare addresses in either format
 *
 * @param a - Left hand side address
 * @param b - Right hand side address
 *
 * @returns Whether a and b are the same address
 */
const addressesAreEqual = (a, b) => a.toLowerCase() === b.toLowerCase();
exports.addressesAreEqual = addressesAreEqual;
/**
 * Convert any number to ETH (remove 18 zeros)
 *
 * @example
 * ```typescript
 * import { toEth } from '@colony/sdk';
 *
 * const oneEther = BigNumber.from("1000000000000000000");
 * console.log(toEth(oneEther)); // 1.0
 * ```
 */
const toEth = (num) => ethers_1.utils.formatEther(num);
exports.toEth = toEth;
/**
 * Convert any number to wei (add 18 zeros)
 *
 * @example
 * ```typescript
 * import { toWei } from '@colony/sdk';
 *
 * const oneEther = '1.0';
 * console.log(toWei(oneEther)); // { BigNumber: "1000000000000000000" }
 * ```
 */
const toWei = (num) => ethers_1.utils.parseEther(num);
exports.toWei = toWei;
/**
 * Short-hand method to convert a number to wei using JS tagged template strings
 *
 * See also here: http://tc39wiki.calculist.org/es6/template-strings/
 *
 * @remarks
 * This is only useful in contexts where the number is hard-coded (e.g. examples)
 *
 * @example
 * ```typescript
 * import { w } from '@colony/sdk';
 *
 * console.log(w`1.0`); // { BigNumber: "1000000000000000000" }
 * ```
 */
const w = (str) => (0, exports.toWei)(str[0]);
exports.w = w;
/**
 * Converts Colony Roles to hex. Result is a binary number where the bits are one and the place of the role index. Then converted to hexadecimal, then padded with zeros to a lenghtof 64
 *
 * @example
 * ```typescript
 * // Binary representation: 0b000101010
 * const roles = colonyRoles2Hex([ColonyRole.Root, ColonyRole.Architecture, ColonyRole.Funding]); // '0x000000000000000000000000000000000000000000000000000000000000002a'
 * ```
 *
 * @param roles - An array of Colony roles
 *
 * @returns A hexadecimal string
 */
const colonyRoles2Hex = (roles) => {
    const hexRoles = roles
        // eslint-disable-next-line no-bitwise
        .reduce((binRoles, roleNum) => binRoles | (1 << roleNum), 0)
        .toString(16);
    return ethers_1.utils.hexZeroPad(`0x${hexRoles}`, 32);
};
exports.colonyRoles2Hex = colonyRoles2Hex;
/**
 * Converts a role hex string (typically returned by a Colony contract) to Colony Roles.
 *
 * @example
 * ```typescript
 * // Binary representation: 0b000101010
 * const roles = hex2ColonyRoles('0x2a'); // [1, 3, 5]
 * ```
 *
 * @param hexStr - A (probably padded) hexadecimal string
 *
 * @returns An array of Colony roles
 */
const hex2ColonyRoles = (hexStr) => {
    const rolesNum = ethers_1.BigNumber.from(hexStr);
    return [...Array(constants_js_1.ColonyRole.LAST_ROLE).keys()]
        .map((i) => {
        if (rolesNum.shr(i).mask(1).eq(1)) {
            return i;
        }
        return null;
    })
        .filter(index_js_1.nonNullable);
};
exports.hex2ColonyRoles = hex2ColonyRoles;
/**
 * Get the child index for a domain inside its corresponding skills parent children array
 *
 * E.g. (the values *will* differ for you!):
 * domainId = 1
 * corresponding skillId = 2
 * parent of skillId 2:
 * ```
 * {
 *  // ...
 *  children: [2]
 * }
 * ```
 * childSkillIndex would be 0 in this case (0-position in children array)
 *
 * @param network - A ColonyNetwork contract
 * @param colony - A Colony contract
 * @param parentDomainId - id of parent domain
 * @param domainId - id of the domain
 *
 * @returns Index in the `children` array (see above)
 */
const getChildIndex = (network, colony, parentDomainId, domainId) => __awaiter(void 0, void 0, void 0, function* () {
    if (ethers_1.BigNumber.from(parentDomainId).eq(ethers_1.BigNumber.from(domainId))) {
        return MaxUint256;
    }
    const { skillId: parentSkillId } = yield colony.getDomain(parentDomainId);
    const { skillId } = yield colony.getDomain(domainId);
    const { children } = yield network.getSkill(parentSkillId);
    const idx = children.findIndex((childSkillId) => childSkillId.eq(skillId));
    if (idx < 0) {
        throw new Error(`Could not find ${domainId} as a child of ${parentDomainId}`);
    }
    return ethers_1.BigNumber.from(idx);
});
exports.getChildIndex = getChildIndex;
/**
 * Hashes to identify the colony extension contracts
 *
 * @param extension - A valid Extension name
 *
 * @returns A hash to identify the extension on the contracts
 */
const getExtensionHash = (extension) => keccak256(toUtf8Bytes(extension));
exports.getExtensionHash = getExtensionHash;
/**
 * Get the associated domain for a pot id
 *
 * @remarks pots can be associated with different types, like domains, payments or tasks
 * See [[`FundingPotAssociatedType`]] for details
 *
 * @param client - Any Colony contract
 * @param potId - The funding pot id
 *
 * @returns The associated domainId
 */
const getPotDomain = (colony, potId) => __awaiter(void 0, void 0, void 0, function* () {
    const { associatedType, associatedTypeId } = yield colony.getFundingPot(potId);
    // In case we add types to this later, we use the official colonyNetwork
    // function available in v5+
    if (colony.getDomainFromFundingPot) {
        return colony.getDomainFromFundingPot(potId);
    }
    switch (associatedType) {
        case constants_js_1.FundingPotAssociatedType.Unassigned: {
            // This is probably the reward pot
            return constants_js_1.Id.RootDomain;
        }
        case constants_js_1.FundingPotAssociatedType.Domain: {
            return associatedTypeId;
        }
        case constants_js_1.FundingPotAssociatedType.Payment: {
            const { domainId } = yield colony.getPayment(associatedTypeId);
            return domainId;
        }
        case constants_js_1.FundingPotAssociatedType.Task: {
            const { domainId } = yield colony.getTask(associatedTypeId);
            return domainId;
        }
        default: {
            throw new Error(`No valid domain found for pot ${potId}`);
        }
    }
});
exports.getPotDomain = getPotDomain;
/**
 * Get the JavaScript timestamp for a block
 *
 * @param provider - ethers compatible Provider
 * @param blockHash - Hash of block to get time for
 *
 * @returns block timestamp in ms
 */
const getBlockTime = (blockHash, provider) => __awaiter(void 0, void 0, void 0, function* () {
    const { timestamp } = yield provider.getBlock(blockHash);
    // timestamp is seconds, Date wants ms
    return timestamp * 1000;
});
exports.getBlockTime = getBlockTime;
/**
 * Get the deployed contract's version
 *
 * Only works with compatible contracts, i.e. Colony contracts or their extensions.
 *
 * @param address - Address of the deployed contract
 * @param signerOrProvider - ethers compatible Signer or Provider
 *
 * @returns The version number of the contract
 */
const getContractVersion = (address, signerOrProvider) => __awaiter(void 0, void 0, void 0, function* () {
    const versionedContract = index_js_2.Versioned__factory.connect(address, signerOrProvider);
    const version = yield versionedContract.version();
    return version.toNumber();
});
exports.getContractVersion = getContractVersion;
/**
 * Try to parse an array of logs with a given interface
 *
 * Will filter out logs that can't be parsed with the given interface
 *
 * @param logs - Array of log entries (usually from a {@link ContractReceipt})
 * @param iface - Ethers compatible contract interface
 *
 * @returns A list of parsed log entries (events)
 */
const parseLogs = (logs, iface) => {
    return logs
        .map((log) => {
        try {
            return iface.parseLog(log);
        }
        catch (e) {
            return null;
        }
    })
        .filter(index_js_1.nonNullable);
};
exports.parseLogs = parseLogs;
