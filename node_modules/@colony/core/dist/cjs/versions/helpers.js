"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExtensionLowestCompatibleColonyVersion = exports.isExtensionCompatible = void 0;
const IColony_js_1 = require("./IColony.js");
const index_js_1 = require("../utils/index.js");
const FundingQueue_js_1 = require("./FundingQueue.js");
const MultisigPermissions_js_1 = require("./MultisigPermissions.js");
const OneTxPayment_js_1 = require("./OneTxPayment.js");
const ReputationBootstrapper_js_1 = require("./ReputationBootstrapper.js");
const StagedExpenditure_js_1 = require("./StagedExpenditure.js");
const StakedExpenditure_js_1 = require("./StakedExpenditure.js");
const StreamingPayments_js_1 = require("./StreamingPayments.js");
const TokenSupplier_js_1 = require("./TokenSupplier.js");
const VotingReputation_js_1 = require("./VotingReputation.js");
const constants_js_1 = require("../constants.js");
const getExtensionIncompatibilityMap = (extension, extensionVersion) => {
    switch (extension) {
        case constants_js_1.Extension.FundingQueue: {
            return FundingQueue_js_1.fundingQueueIncompatibilityMap[extensionVersion];
        }
        case constants_js_1.Extension.IVotingReputation: {
            return VotingReputation_js_1.votingReputationIncompatibilityMap[extensionVersion];
        }
        case constants_js_1.Extension.MultisigPermissions: {
            return MultisigPermissions_js_1.multisigPermissionsIncompatibilityMap[extensionVersion];
        }
        case constants_js_1.Extension.OneTxPayment: {
            return OneTxPayment_js_1.oneTxPaymentIncompatibilityMap[extensionVersion];
        }
        case constants_js_1.Extension.ReputationBootstrapper: {
            return ReputationBootstrapper_js_1.reputationBootstrapperIncompatibilityMap[extensionVersion];
        }
        case constants_js_1.Extension.StagedExpenditure: {
            return StagedExpenditure_js_1.stagedExpenditureIncompatibilityMap[extensionVersion];
        }
        case constants_js_1.Extension.StakedExpenditure: {
            return StakedExpenditure_js_1.stakedExpenditureIncompatibilityMap[extensionVersion];
        }
        case constants_js_1.Extension.StreamingPayments: {
            return StreamingPayments_js_1.streamingPaymentsIncompatibilityMap[extensionVersion];
        }
        case constants_js_1.Extension.TokenSupplier: {
            return TokenSupplier_js_1.tokenSupplierIncompatibilityMap[extensionVersion];
        }
        case constants_js_1.Extension.VotingReputation: {
            return VotingReputation_js_1.votingReputationIncompatibilityMap[extensionVersion];
        }
        default:
            return (0, index_js_1.assertExhaustiveSwitch)(extension, 'Could not find extension with name');
    }
};
/**
 * Checks the compatibility of an extension version with a colony version it requests to be installed in
 * Returns `true` if an extension version is compatible with the given colony version
 *
 * @param extension - A valid `Extension` contract name
 * @param extensionVersion - The version of the extension to check against the colony
 * @param colonyVersion - The version of the colony to check for
 *
 * @returns indication whether extension in given version is compatible with colony at the given version
 */
const isExtensionCompatible = (extension, extensionVersion, colonyVersion) => {
    const map = getExtensionIncompatibilityMap(extension, extensionVersion);
    if (!map) {
        console.warn(`Version ${extensionVersion} of ${extension} is unknown. Compatibility check disabled`);
        return true;
    }
    return !map.includes(colonyVersion);
};
exports.isExtensionCompatible = isExtensionCompatible;
/**
 * Calculates and returns the lowest compatible colony version for a given version of an extension
 *
 * @param extension - A valid `Extension` contract name
 * @param extensionVersion - The version of the extension to check
 *
 * @returns the lowest compatible colony version for a given version of an extension
 */
const getExtensionLowestCompatibleColonyVersion = (extension, extensionVersion) => {
    const map = getExtensionIncompatibilityMap(extension, extensionVersion);
    if (!map) {
        throw new Error(`Could not find incompatibility map for extension "${extension}" with version: ${extensionVersion}`);
    }
    if (!map.length) {
        return IColony_js_1.COLONY_VERSIONS[0];
    }
    const colonyVersion = IColony_js_1.COLONY_VERSIONS.find((v) => v === map[map.length - 1] + 1);
    if (colonyVersion === undefined || null) {
        throw new Error(`No compatible colony version found for extension "${extension}" with version: ${extensionVersion}`);
    }
    return colonyVersion;
};
exports.getExtensionLowestCompatibleColonyVersion = getExtensionLowestCompatibleColonyVersion;
